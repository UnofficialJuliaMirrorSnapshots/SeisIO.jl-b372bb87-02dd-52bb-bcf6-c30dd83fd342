%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Introduction}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{SeisIO Documentation}
\date{Sep 03, 2019}
\release{0.3.0}
\author{Joshua Jones}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


SeisIO is a collection of utilities for reading and downloading geophysical timeseries data.


\chapter{Intro}
\label{\detokenize{index:intro}}

\section{Introduction}
\label{\detokenize{src/intro:introduction}}\label{\detokenize{src/intro::doc}}
SeisIO is a framework for working with univariate geophysical data.
SeisIO is designed around three basic principles:
\begin{itemize}
\item {} 
Ease of use: you shouldn’t \sphinxstyleemphasis{need} a PhD to study geophysical data.

\item {} 
Fluidity: working with data shouldn’t feel \sphinxstyleemphasis{clumsy}.

\item {} 
Performance: speed and efficient memory usage \sphinxstyleemphasis{matter}.

\end{itemize}

The project is home to an expanding set of web clients, file format readers,
and analysis utilities.


\subsection{Overview}
\label{\detokenize{src/intro:overview}}
SeisIO stores data in minimalist containers that track the bare necessities for
analysis. New data are easily added with basic commands like \sphinxcode{\sphinxupquote{+}}. Unwanted
channels can be removed just as easily. Data can be saved to a native SeisIO
format or written to other supported file formats.


\subsection{Installation}
\label{\detokenize{src/intro:installation}}
From the Julia prompt: press \sphinxcode{\sphinxupquote{{]}}} to enter the Pkg environment, then type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add} \PYG{n}{SeisIO}\PYG{p}{;} \PYG{n}{build}\PYG{p}{;} \PYG{n}{precompile}
\end{sphinxVerbatim}

Dependencies should install automatically. To verify that everything works
correctly, type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test} \PYG{n}{SeisIO}
\end{sphinxVerbatim}

and allow 10-20 minutes for tests to complete. To get started, exit the Pkg
environment by pressing Backspace or Control + C, then type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{using} \PYG{n}{SeisIO}
\end{sphinxVerbatim}

at the Julia prompt. You’ll need to repeat that last step whenever you restart
Julia, as with any command-line interpreter (CLI) language.


\subsection{Getting Started}
\label{\detokenize{src/intro:getting-started}}
The {\hyperref[\detokenize{src/tutorial:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorial}}}} is designed as a gentle introduction for people
less familiar with the Julia language. If you already have some familiarity
with Julia, you probably want to start with one of the following topics:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{src/working_with_data:wwd}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with Data}}}}: learn how to manage data using SeisIO

\item {} 
{\hyperref[\detokenize{src/Formats/fileformats:readdata}]{\sphinxcrossref{\DUrole{std,std-ref}{Reading Data}}}}: learn how to read data from file

\item {} 
{\hyperref[\detokenize{src/Web/webclients:getdata}]{\sphinxcrossref{\DUrole{std,std-ref}{Requesting Data}}}}: learn how to make web requests

\end{itemize}


\subsection{Updating}
\label{\detokenize{src/intro:updating}}
From the Julia prompt: press \sphinxcode{\sphinxupquote{{]}}} to enter the Pkg environment, then type
\sphinxcode{\sphinxupquote{update}}. Once updates finish, restart Julia to use them.


\subsection{Getting Help}
\label{\detokenize{src/intro:getting-help}}
In addition to these documents, a number of help documents can be called at the
Julia prompt. These commands are a useful starting point:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?chanspec           \PYGZsh{} how to specify channels in web requests
?get\PYGZus{}data           \PYGZsh{} how to download data
?read\PYGZus{}data          \PYGZsh{} how to read data from file
?timespec           \PYGZsh{} how to specify times in web requests and data processing
?seed\PYGZus{}support       \PYGZsh{} how much of the SEED data standard is supported?
?seis\PYGZus{}www           \PYGZsh{} list strings for data sources in web requests
?SeisData           \PYGZsh{} information about SeisIO data types
?SeisIO.KW          \PYGZsh{} SeisIO shared keywords and their meanings
\end{sphinxVerbatim}


\section{First Steps}
\label{\detokenize{src/tutorial:first-steps}}\label{\detokenize{src/tutorial:tutorial}}\label{\detokenize{src/tutorial::doc}}
SeisIO is designed around easy, fluid, and fast data access.
At the most basic level, SeisIO uses an array-like custom object called a
\sphinxstylestrong{SeisChannel} for single-channel data; \sphinxstylestrong{SeisData} objects store
multichannel data and can be created by combining SeisChannels.


\subsection{Start Here}
\label{\detokenize{src/tutorial:start-here}}
Create a new, empty \sphinxstylestrong{SeisChannel} object with


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{Ch~=~SeisChannel()}}}
\end{fulllineitems}


The meanings of the field names are explained {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}; you can also type
\sphinxcode{\sphinxupquote{?SeisChannel}} at the Julia prompt. You can edit field values manually, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ch}\PYG{o}{.}\PYG{n}{loc} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{90.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{9300.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}
\PYG{n}{Ch}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{South pole}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

or you can set them with keywords at creation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ch} \PYG{o}{=} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MANOWAR JAJAJA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

SeisData structures are collections of channel data. They can be created with
the SeisData() command, which can optionally create any number of empty channels
at a time, e.g.,


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~SeisData(1)}}}
\end{fulllineitems}


They can be explored similarly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S}\PYG{o}{.}\PYG{n}{name}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{South pole}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{90.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{9300.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}
\end{sphinxVerbatim}

A collection of channels becomes a SeisData structure:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~SeisData(SeisChannel(),~SeisChannel())}}}
\end{fulllineitems}


You can push channels onto existing SeisData structures, like adding one key
to a dictionary:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{push!(S,~Ch)}}}
\end{fulllineitems}


Note that this copies Ch to a new channel in S \textendash{} S{[}3{]} is not a view into C.
This is deliberate, as otherwise the workspace quickly becomes a mess of
redundant channels. Clean up with \sphinxcode{\sphinxupquote{Ch = {[}{]}}} to free memory before moving on.


\subsection{Operations on SeisData structures}
\label{\detokenize{src/tutorial:operations-on-seisdata-structures}}
We’re now ready for a short tutorial of what we can do with data structures.
In the commands below, as in most of this documentation, \sphinxstylestrong{Ch} is a
SeisChannel object and \sphinxstylestrong{S} is a SeisData object.


\subsubsection{Adding channels to a SeisData structure}
\label{\detokenize{src/tutorial:adding-channels-to-a-seisdata-structure}}
You’ve already seen one way to add a channel to SeisData: push!(S, SeisChannel())
adds an empty channel. Here are others:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{append!(S,~SeisData(n))}}}
\end{fulllineitems}


Adds n channels to the end of S by creating a new n-channel SeisData and
appending it, similar to adding two dictionaries together.

These methods are aliased to the addition operator:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{+}\PYG{o}{=} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} equivalent to push!(S, SeisChannel())}
\PYG{n}{S} \PYG{o}{+}\PYG{o}{=} \PYG{n}{randseisdata}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} adds a random 3\PYGZhy{}element SeisData structure to S in place}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{SeisData}\PYG{p}{(}\PYG{n}{randseisdata}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
      \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.SEP..EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Darth Exploded}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{loc}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{46.1967}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{122.1875}\PYG{p}{,} \PYG{l+m+mi}{1440}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Most web request functions can append to an existing SeisData object by placing
an exclamation mark after the function call. You can see how this works by
running the {\hyperref[\detokenize{src/Appendices/examples:webex}]{\sphinxcrossref{\DUrole{std,std-ref}{examples}}}}.


\subsubsection{Search, Sort, and Prune}
\label{\detokenize{src/tutorial:search-sort-and-prune}}
The easiest way to find channels of interest in a data structure is to
use findid, but you can obtain an array of partial matches with findchan:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{SeisData}\PYG{p}{(}\PYG{n}{randseisdata}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
      \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.SEP..EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Darth Exploded}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{loc}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{46.1967}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{122.1875}\PYG{p}{,} \PYG{l+m+mi}{1440}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{findid}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.SEP..EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} 7}
\PYG{n}{findchan}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} [7], maybe others depending on randseisdata}
\end{sphinxVerbatim}

You can sort by channel ID with the \sphinxtitleref{sort} command.

Several functions exist to prune empty and unwanted channels from SeisData
structures.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
delete!(S, 1:2)  \PYGZsh{} Delete first two channels of S
S \PYGZhy{}= 3           \PYGZsh{} Delete third channel of S

\PYGZsh{} Extract S[1] as a SeisChannel, removing it from S
C = pull(S, 1)

\PYGZsh{} Delete all channels whose S.x is empty
prune!(S)

\PYGZsh{} Delete channels containing \PYGZdq{}.SEP.\PYGZdq{}
delete!(S, \PYGZdq{}.SEP.\PYGZdq{}, exact=false)
\end{sphinxVerbatim}

In the last example, specifying exact=false means that any channel whose ID
partly matches the string “.SEP.” gets deleted; by default, passing
a string to delete!(S, str) only matches channels where str is the exact ID.
This is an efficient way to remove unresponsive subnets and unwanted channel
types, but beware of clumsy over-matching.


\subsection{Next Steps}
\label{\detokenize{src/tutorial:next-steps}}
Because tracking arbitrary operations can be difficult, several functions have
been written to keep track of data and operations in a semi-automated way. See
the next section, {\hyperref[\detokenize{src/working_with_data:wwd}]{\sphinxcrossref{\DUrole{std,std-ref}{working with data}}}}, for detailed discussion of
managing data from the Julia command prompt.


\section{Working with Data}
\label{\detokenize{src/working_with_data:working-with-data}}\label{\detokenize{src/working_with_data:wwd}}\label{\detokenize{src/working_with_data::doc}}
This section describes how to track and manage SeisIO data.


\subsection{Creating Data Containers}
\label{\detokenize{src/working_with_data:creating-data-containers}}
Create a new, empty object using any of the following commands:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{7}|\X{6}{7}|}
\hline
\sphinxstyletheadfamily 
Object
&\sphinxstyletheadfamily 
Purpose
\\
\hline
SeisChannel()
&
A single channel of univariate (usually time-series) data
\\
\hline
SeisData()
&
Multichannel univariate (usually time-series) data
\\
\hline
SeisHdr()
&
Header structure for discrete seismic events
\\
\hline
SeisEvent()
&
Discrete seismic events; includes SeisHdr and SeisData objects
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Acquiring Data}
\label{\detokenize{src/working_with_data:acquiring-data}}\begin{itemize}
\item {} 
Read files with {\hyperref[\detokenize{src/Formats/fileformats:readdata}]{\sphinxcrossref{\DUrole{std,std-ref}{read\_data}}}}

\item {} 
Make web requets with {\hyperref[\detokenize{src/Web/webclients:getdata}]{\sphinxcrossref{\DUrole{std,std-ref}{get\_data}}}}

\item {} 
Initiate real-time streaming sessions to SeisData objects with {\hyperref[\detokenize{src/Web/seedlink:seedlink-section}]{\sphinxcrossref{\DUrole{std,std-ref}{SeedLink!}}}}

\end{itemize}


\subsection{Keeping Track}
\label{\detokenize{src/working_with_data:keeping-track}}
A number of auxiliary functions exist to keep track of channels:
\index{findchan() (built-in function)@\spxentry{findchan()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/working_with_data:findchan}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findchan}}}{\emph{id::String}, \emph{S::SeisData}}{}
\end{fulllineitems}

\index{findchan() (built-in function)@\spxentry{findchan()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findchan}}}{\emph{S::SeisData}, \emph{id::String}}{}
\end{fulllineitems}


Get all channel indices i in S with id \(\in\) S.id{[}i{]}. Can do partial id
matches, e.g. findchan(S, “UW.”) returns indices to all channels whose IDs begin
with “UW.”.
\index{findid() (built-in function)@\spxentry{findid()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/working_with_data:findid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findid}}}{\emph{S::SeisData}, \emph{id}}{}
\end{fulllineitems}


Return the index of the first channel in \sphinxstylestrong{S} where id = \sphinxstylestrong{id}. Requires an
exact string match; intended as a low-memory equivalent to findfirst for
ids.
\index{findid() (built-in function)@\spxentry{findid()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findid}}}{\emph{S::SeisData}, \emph{Ch::SeisChannel}}{}
\end{fulllineitems}


Equivalent to findfirst(S.id.==Ch.id).


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{namestrip!(S{[},~convention{]})}}}
\end{fulllineitems}


Remove bad characters from the :name fields of \sphinxstylestrong{S}. Specify convention as a
string (default is “File”):


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Convention
&\sphinxstyletheadfamily 
Characters Removed:sup:\sphinxtitleref{(a)}
\\
\hline
“File”
&
\sphinxcode{\sphinxupquote{"\$*/:\textless{}\textgreater{}?@\textbackslash{}\textasciicircum{}\textbar{}\textasciitilde{}DEL}}
\\
\hline
“HTML”
&
\sphinxcode{\sphinxupquote{"\&';\textless{}\textgreater{}©DEL}}
\\
\hline
“Julia”
&
\sphinxcode{\sphinxupquote{\$\textbackslash{}DEL}}
\\
\hline
“Markdown”
&
\sphinxcode{\sphinxupquote{!\#()*+-.{[}\textbackslash{}{]}\_{}`\{\}}}
\\
\hline
“SEED”
&
\sphinxcode{\sphinxupquote{.DEL}}
\\
\hline
“Strict”
&
\sphinxcode{\sphinxupquote{!"\#\$\%\&'()*+,-./:;\textless{}=\textgreater{}?@{[}\textbackslash{}{]}\textasciicircum{}{}`\{\textbar{}\}\textasciitilde{}DEL}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

$^{\text{(a)}}$ \sphinxcode{\sphinxupquote{DEL}} here is \textbackslash{}x7f (ASCII/Unicode U+007f).
\index{timestamp() (built-in function)@\spxentry{timestamp()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/working_with_data:timestamp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{timestamp}}}{}{}
\end{fulllineitems}


Return current UTC time formatted yyyy-mm-ddTHH:MM:SS.uuu.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{track\_off!(S)}}}
\end{fulllineitems}


Turn off tracking in S and return a boolean vector of which channels were added
or altered significantly.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{track\_on!(S)}}}
\end{fulllineitems}


Begin tracking changes in S. Tracks changes to :id, channel additions, and
changes to data vector sizes in S.x.

Does not track data processing operations on any channel i unless
length(S.x{[}i{]}) changes for channel i (e.g. filtering is not tracked).

\sphinxstylestrong{Warning}: If you have or suspect gapped data in any channel, calling
ungap! while tracking is active will flag a channel as changed.


\subsubsection{Source Logging}
\label{\detokenize{src/working_with_data:source-logging}}
The :src field records the \sphinxstyleemphasis{last} source used to populate each channel (usually
a file name and path or a web request URL).

When a data source is added to a channel, including the first time data are
added, this is recorded in :notes with the syntax (timestamp) +src: (function) (src).


\subsection{Channel Maintenance}
\label{\detokenize{src/working_with_data:channel-maintenance}}
A few functions exist specifically to simplify data maintenance:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{prune!(S::SeisData)}}}
\end{fulllineitems}


Delete all channels from S that have no data (i.e. S.x is empty or non-existent).


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{C~=~pull(S::SeisData,~id::String)}}}
\end{fulllineitems}


Extract the first channel with id=id from S and return it as a new SeisChannel
structure. The corresponding channel in S is deleted.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{C~=~pull(S::SeisData,~i::integer)}}}
\end{fulllineitems}


Extract channel \sphinxstylestrong{i} from \sphinxstylestrong{S} as a new SeisChannel object \sphinxstylestrong{C}, and delete
the corresponding channel from \sphinxstylestrong{S}.


\subsection{Taking Notes}
\label{\detokenize{src/working_with_data:taking-notes}}
Functions that add and process data note these operations in the :notes field
of each object affected. One can also add custom notes with the note! command:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{note!(S,~i,~str)}}}
\end{fulllineitems}


Append \sphinxstylestrong{str} with a timestamp to the :notes field of channel number \sphinxstylestrong{i} of \sphinxstylestrong{S}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{note!(S,~id,~str)}}}
\end{fulllineitems}


As above for the first channel in \sphinxstylestrong{S} whose id is an exact match to \sphinxstylestrong{id}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{note!(S,~str)}}}
\end{fulllineitems}


if \sphinxstylestrong{str* mentions a channel name or ID, only the corresponding channel(s) in **S} is annotated; otherwise, all channels are annotated.

Clear all notes from channel \sphinxcode{\sphinxupquote{i}} of \sphinxcode{\sphinxupquote{S}}.

\sphinxcode{\sphinxupquote{clear\_notes!(S, id)}}

Clear all notes from the first channel in \sphinxcode{\sphinxupquote{S}} whose id field exactly matches \sphinxcode{\sphinxupquote{id}}.

\sphinxcode{\sphinxupquote{clear\_notes!(S)}}

Clear all notes from every channel in \sphinxcode{\sphinxupquote{S}}.


\chapter{Files}
\label{\detokenize{index:files}}

\section{Geophysical Data}
\label{\detokenize{src/Formats/fileformats:geophysical-data}}\label{\detokenize{src/Formats/fileformats:readdata}}\label{\detokenize{src/Formats/fileformats::doc}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{read\_data!(S,~fmt::String,~filepat~{[},~KWs{]})}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~read\_data(fmt::String,~filepat~{[},~KWs{]})}}}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] Read data from a supported file format into memory.
\item[] 
\item[] \sphinxstylestrong{fmt}
\item[] Lowercase string describin the file format. See below.
\item[] 
\item[] \sphinxstylestrong{filepat}
\item[] Read files with names matching pattern \sphinxcode{\sphinxupquote{filepat}}. Supports wildcards.
\item[] 
\item[] \sphinxstylestrong{KWs}
\item[] Keyword arguments; see also {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO standard KWs}}}} or type \sphinxcode{\sphinxupquote{?SeisIO.KW}}.
\item[] Standard keywords: full, nx\_add, nx\_new, v
\item[] Other keywords: See below.
\end{DUlineblock}


\subsection{Supported File Formats}
\label{\detokenize{src/Formats/fileformats:supported-file-formats}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{2}{3}|\X{1}{3}|}
\hline
\sphinxstyletheadfamily 
File Format
&\sphinxstyletheadfamily 
String
\\
\hline
AH-1
&
ah1
\\
\hline
AH-2
&
ah2
\\
\hline
GeoCSV, time-sample pair
&
geocsv
\\
\hline
GeoCSV, sample list
&
geocsv.slist
\\
\hline
Lennartz ASCII
&
lenartzascii
\\
\hline
Mini-SEED, SEED
&
mseed
\\
\hline
PASSCAL SEG Y
&
passcal
\\
\hline
SAC
&
sac
\\
\hline
SEG Y (rev 0 or rev 1)
&
segy
\\
\hline
SUDS
&
suds
\\
\hline
UW
&
uw
\\
\hline
Win32
&
win32
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Strings are case-sensitive to prevent any performance impact from using matches
and/or lowercase().


\subsection{Supported Keywords}
\label{\detokenize{src/Formats/fileformats:supported-keywords}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{8}|\X{1}{8}|\X{1}{8}|\X{1}{8}|\X{4}{8}|}
\hline
\sphinxstyletheadfamily 
KW
&\sphinxstyletheadfamily 
Used By
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Meaning
\\
\hline
cf
&
win32
&
String
&
“”
&
win32 channel info filestr
\\
\hline
full
&
ah1, ah2
&
Bool
&
false
&
read full header into \sphinxstylestrong{:misc}?
\\
\hline&
sac
&&&\\
\hline&
segy
&&&\\
\hline&
uw
&&&\\
\hline
nx\_add
&
mseed
&
Int64
&
360000
&
minimum size increase of \sphinxstylestrong{:x}
\\
\hline
nx\_new
&
mseed
&
Int64
&
86400000
&
length of \sphinxstylestrong{:x} for new channels
\\
\hline
jst
&
win32
&
Bool
&
true
&
are sample times JST (UTC+9)?
\\
\hline
swap
&
seed
&
Bool
&
true
&
byte swap?
\\
\hline
v
&
ah
&
Int64
&
0
&
verbosity
\\
\hline&
mseed
&&&\\
\hline&
uw
&&&\\
\hline&
win32
&&&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Performance Tip}
\label{\detokenize{src/Formats/fileformats:performance-tip}}
With mseed or win32 data, adjust \sphinxtitleref{nx\_new} and \sphinxtitleref{nx\_add} based on the sizes of
the data vectors that you expect to read. If the largest has \sphinxtitleref{Nmax} samples,
and the smallest has \sphinxtitleref{Nmin}, we recommend \sphinxtitleref{nx\_new=Nmin} and \sphinxtitleref{nx\_add=Nmax-Nmin}.

Default values can be changed in SeisIO keywords, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SeisIO}\PYG{o}{.}\PYG{n}{KW}\PYG{o}{.}\PYG{n}{nx\PYGZus{}new} \PYG{o}{=} \PYG{l+m+mi}{60000}
\PYG{n}{SeisIO}\PYG{o}{.}\PYG{n}{KW}\PYG{o}{.}\PYG{n}{nx\PYGZus{}add} \PYG{o}{=} \PYG{l+m+mi}{360000}
\end{sphinxVerbatim}

The system-wide defaults are \sphinxtitleref{nx\_new=86400000} and \sphinxtitleref{nx\_add=360000}. Using these
values with very small jobs will greatly decrease performance.


\paragraph{Examples}
\label{\detokenize{src/Formats/fileformats:examples}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{S = read\_data("uw", "99011116541W", full=true)}}}] \leavevmode\begin{itemize}
\item {} 
Read UW-format data file \sphinxcode{\sphinxupquote{99011116541W}}

\item {} 
Store full header information in \sphinxcode{\sphinxupquote{:misc}}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{read\_data!(S, "sac", "MSH80*.SAC")}}}] \leavevmode\begin{itemize}
\item {} 
Read SAC-format files matching string pattern \sphinxtitleref{MSH80*.SAC}

\item {} 
Read into existing SeisData object \sphinxcode{\sphinxupquote{S}}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{S = read\_data("win32", "20140927*.cnt", cf="20140927*ch", nx\_new=360000)}}}] \leavevmode\begin{itemize}
\item {} 
Read win32-format data files with names matching pattern \sphinxcode{\sphinxupquote{2014092709*.cnt}}

\item {} 
Use ASCII channel information filenames that match pattern \sphinxcode{\sphinxupquote{20140927*ch}}

\item {} 
Assign new channels an initial size of \sphinxcode{\sphinxupquote{nx\_new}} samples

\end{itemize}

\end{description}

\end{enumerate}


\subsection{Format Descriptions and Notes}
\label{\detokenize{src/Formats/fileformats:format-descriptions-and-notes}}
\sphinxstylestrong{AH} (Ad-Hoc) was developed as a machine-independent seismic data format
based on External Data Representation (XDR).

\sphinxhref{http://geows.ds.iris.edu/documents/GeoCSV.pdf}{GeoCSV}: an extension of
“human-readable”, tabular file format Comma-Separated Values (CSV).

\sphinxstylestrong{Lennartz ASCII}: ASCII output of Lennartz portable digitizers.

\sphinxhref{https://www.passcal.nmt.edu/content/seg-y-what-it-is}{PASSCAL}: A single-
channel variant of SEG Y with no file header, developed by PASSCAL/New Mexico
Tech and used with PASSCAL field equipment through the late 2000s.

\sphinxhref{https://www.fdsn.org/seed\_manual/SEEDManual\_V2.4.pdf}{SEED}: SEED stands for
Standard for the Exchange of Earthquake Data; used by the International
Federation of Digital Seismograph Networks (FDSN) as an omnibus seismic data
standard. mini-SEED is a data-only variant that uses only data blockettes.

\sphinxhref{https://ds.iris.edu/files/sac-manual/manual/file\_format.html}{SAC}: the
Seismic Analysis Code data format, originally developed for the eponymous
command-line interpreter. Widely used, and supported in virtually every
programming language.

\sphinxhref{http://wiki.seg.org/wiki/SEG\_Y}{SEG Y}: Society of Exploration Geophysicists
data format. Common in the energy industry, developed and maintained by the SEG.
Only SEG Y rev 0 and \sphinxhref{https://seg.org/Portals/0/SEG/News\%20and\%20Resources/Technical\%20Standards/seg\_y\_rev1.pdf}{rev 1}
with standard headers are supported.

\sphinxstylestrong{UW}: the University of Washington data format has no online reference and is
no longer in use. Created by the Pacific Northwest Seismic Network for event
archival; used from the 1970s through early 2000s. A UW event is described by a
pickfile and corresponding data file, whose names are identical except for the
last character; for example, files 99062109485o and 99062109485W together
describe event 99062109485. Unlike the win32 data format, the data file is
self-contained; the pick file is not required to use raw trace data. However,
like the win32 data format, instrument locations are stored in an external
human-maintained text file. Only UW-2 data files are supported by SeisIO; we
have never encountered a UW-1 data file outside of Exabyte tapes and have no
reason to suspect that any remain in circulation.

\sphinxhref{http://eoc.eri.u-tokyo.ac.jp/WIN/Eindex.html}{Win32}: data format developed
by the Earthquake Research Institute (ERI), University of Tokyo, Japan. Data
are typically divided into files that contain a minute of continuous
data from several channels. Data within each file are stored by channel in
one-second segments as variable-precision delta-encoded integers. Channel
information is retrieved from an external channel information file. Although
accurate channel files are needed to use win32 data, these files are not
strictly controlled by any central authority. Inconsistencies in channel
parameters, particularly gains, are known to exist.


\subsection{Other File I/O Functions}
\label{\detokenize{src/Formats/fileformats:other-file-i-o-functions}}\index{rseis() (built-in function)@\spxentry{rseis()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:rseis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rseis}}}{\emph{fname}}{}
\end{fulllineitems}


Read SeisIO native format data into an array of SeisIO structures.
\index{sachdr() (built-in function)@\spxentry{sachdr()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:sachdr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sachdr}}}{\emph{fname}}{}
\end{fulllineitems}


Print headers from SAC file to stdout.
\index{segyhdr() (built-in function)@\spxentry{segyhdr()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:segyhdr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{segyhdr}}}{\emph{fname}\sphinxoptional{, \emph{PASSCAL=true::Bool}}}{}
\end{fulllineitems}


Print headers from SEG Y file to stdout. Specify \sphinxcode{\sphinxupquote{passcal=true}} for PASSCAL SEG Y.
\index{uwdf() (built-in function)@\spxentry{uwdf()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:uwdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uwdf}}}{\emph{dfname}}{}
\end{fulllineitems}


Parse UW event data file \sphinxcode{\sphinxupquote{dfname}} into a new SeisEvent structure.
\index{writesac() (built-in function)@\spxentry{writesac()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:writesac}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writesac}}}{\emph{S}\sphinxoptional{, \emph{ts=true}}}{}
\end{fulllineitems}


Write SAC data to SAC files with auto-generated names. Specify ts=true to write
time stamps; this will flag the file as generic x-y data in the SAC interpreter.
\index{wseis() (built-in function)@\spxentry{wseis()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:wseis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{wseis}}}{\emph{fname}, \emph{S}}{}
\end{fulllineitems}

\index{wseis() (built-in function)@\spxentry{wseis()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{wseis}}}{\emph{fname}, \emph{S}, \emph{T}, \emph{U...}}{}
\end{fulllineitems}


Write SeisIO data to fname. Multiple objects can be written at once.


\section{XML Meta-Data}
\label{\detokenize{src/Formats/xml:xml-meta-data}}\label{\detokenize{src/Formats/xml:xml}}\label{\detokenize{src/Formats/xml::doc}}
SeisIO can parse the following XML metadata formats:
* QuakeML Version 1.2 (Quake submodule)
* StationXML Version 1.1


\subsection{StationXML}
\label{\detokenize{src/Formats/xml:stationxml}}\index{read\_sxml() (built-in function)@\spxentry{read\_sxml()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/xml:read_sxml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_sxml}}}{\emph{fpat}\sphinxoptional{, \emph{KWs}}}{}
\end{fulllineitems}


Read FDSN StationXML files matching string pattern \sphinxstylestrong{fpat} into a new SeisData
object.

\begin{DUlineblock}{0em}
\item[] Keywords:
\item[] \sphinxcode{\sphinxupquote{s}}: start time. Format “YYYY-MM-DDThh:mm:ss”, e.g., “0001-01-01T00:00:00”.
\item[] \sphinxcode{\sphinxupquote{t}}: termination (end) time. Format “YYYY-MM-DDThh:mm:ss”.
\item[] \sphinxcode{\sphinxupquote{msr}}: (Bool) read instrument response info as MultiStageResp?
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{How often is MultiStageResp needed?}
\item[] Virtually never.
\end{DUlineblock}

By default, the \sphinxstylestrong{:resp} field of each channel contains a simple instrument
response with poles, zeros, sensitivity (\sphinxstylestrong{:a0}), and sensitivity frequency
(\sphinxstylestrong{:f0}). Very few use cases require more detail than this.

The option \sphinxstylestrong{msr=true} processes XML files to give full response information
at every documented stage of the acquisition process: sampling, digitization,
FIR filtering, decimation, etc.


\subsection{QuakeML}
\label{\detokenize{src/Formats/xml:quakeml}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_qml}}}{\emph{fpat}}{}
\end{fulllineitems}


Read QuakeML files matching string pattern \sphinxstylestrong{fpat}. Returns a tuple containing
an array of \sphinxstylestrong{SeisHdr} objects \sphinxstylestrong{H} and an array of \sphinxstylestrong{SeisSrc} objects \sphinxstylestrong{R}.
Each pair (H{[}i{]}, R{[}i{]}) describes the preferred location (origin, SeisHdr) and
event source (focal mechanism or moment tensor, SeisSrc) of event \sphinxstylestrong{i}.

If multiple focal mechanisms, locations, or magnitudes are present in a single
Event element of the XML file(s), the following rules are used to select one of
each per event:

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{FocalMechanism}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1. \sphinxstylestrong{preferredFocalMechanismID} if present
\item[] 2. Solution with best-fitting moment tensor
\item[] 3. First \sphinxstylestrong{FocalMechanism} element
\item[] 
\end{DUlineblock}
\item[] \sphinxstylestrong{Magnitude}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1. \sphinxstylestrong{preferredMagnitudeID} if present
\item[] 2. Magnitude whose ID matches \sphinxstylestrong{MomentTensor/derivedOriginID}
\item[] 3. Last moment magnitude (lowercase scale name begins with “mw”)
\item[] 4. First \sphinxstylestrong{Magnitude} element
\item[] 
\end{DUlineblock}
\item[] \sphinxstylestrong{Origin}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1. \sphinxstylestrong{preferredOriginID} if present
\item[] 2. \sphinxstylestrong{derivedOriginID} from the chosen \sphinxstylestrong{MomentTensor} element
\item[] 3. First \sphinxstylestrong{Origin} element
\end{DUlineblock}
\end{DUlineblock}

Non-essential QuakeML data are saved to \sphinxtitleref{misc} in each SeisHdr or SeisSrc object
as appropriate.


\chapter{Web}
\label{\detokenize{index:web}}

\section{Web Requests}
\label{\detokenize{src/Web/webclients:web-requests}}\label{\detokenize{src/Web/webclients:getdata}}\label{\detokenize{src/Web/webclients::doc}}
Data requests use \sphinxcode{\sphinxupquote{get\_data!}} for FDSN or IRIS data services; for (near)
real-time streaming, see {\hyperref[\detokenize{src/Web/seedlink:seedlink-section}]{\sphinxcrossref{\DUrole{std,std-ref}{SeedLink}}}}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{get\_data!(S,~method,~channels;~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~get\_data(method,~channels;~KWs)}}}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] Retrieve time-series data from a web archive to SeisData structure \sphinxstylestrong{S}.
\item[] 
\item[] \sphinxstylestrong{method}
\item[] \sphinxstylestrong{“IRIS”}: {\hyperref[\detokenize{src/Web/webclients:irisws}]{\sphinxcrossref{\DUrole{std,std-ref}{IRISWS}}}}.
\item[] \sphinxstylestrong{“FDSN”}: {\hyperref[\detokenize{src/Web/webclients:fdsnws}]{\sphinxcrossref{\DUrole{std,std-ref}{FDSNWS dataselect}}}}. Change FDSN servers with keyword \sphinxcode{\sphinxupquote{src}} using the {\hyperref[\detokenize{src/Appendices/web_syntax:servers}]{\sphinxcrossref{\DUrole{std,std-ref}{server list}}}} (also available by typing \sphinxcode{\sphinxupquote{?seis\_www}}).
\item[] 
\item[] \sphinxstylestrong{channels}
\item[] Channels to retrieve; can be passed as a {\hyperref[\detokenize{src/Appendices/web_syntax:cid}]{\sphinxcrossref{\DUrole{std,std-ref}{string, string array, or parameter file}}}}. Type \sphinxcode{\sphinxupquote{?chanspec}} at the Julia prompt for more info.
\item[] 
\item[] \sphinxstylestrong{KWs}
\item[] Keyword arguments; see also {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO standard KWs}}}} or type \sphinxcode{\sphinxupquote{?SeisIO.KW}}.
\item[] Standard keywords: fmt, nd, opts, rad, reg, si, to, v, w, y
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{msr}}: get instrument responses as MultiStageResonse? (FDSN only)
\item[] \sphinxcode{\sphinxupquote{s}}: Start time
\item[] \sphinxcode{\sphinxupquote{t}}: Termination (end) time
\item[] \sphinxcode{\sphinxupquote{xf}}: XML file name for station XML
\end{DUlineblock}


\subsection{Examples}
\label{\detokenize{src/Web/webclients:examples}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxcode{\sphinxupquote{get\_data!(S, "FDSN", "UW.SEP..EHZ,UW.SHW..EHZ,UW.HSR..EHZ", "IRIS", t=(-600))}}: using FDSNWS, get the last 10 minutes of data from three short-period vertical-component channels at Mt. St. Helens, USA.

\item {} 
\sphinxcode{\sphinxupquote{get\_data!(S, "IRIS", "CC.PALM..EHN", "IRIS", t=(-120), f="sacbl")}}: using IRISWS, fetch the last two minutes of data from component EHN, station PALM (Palmer Lift (Mt. Hood), OR, USA,), network CC (USGS Cascade Volcano Observatory, Vancouver, WA, USA), in bigendian SAC format, and merge into SeisData structure \sphinxtitleref{S}.

\item {} 
\sphinxcode{\sphinxupquote{get\_data!(S, "FDSN", "CC.TIMB..EHZ", "IRIS", t=(-600), w=true)}}: using FDSNWS, get the last 10 minutes of data from channel EHZ, station TIMB (Timberline Lodge, OR, USA), save the data directly to disk, and add it to SeisData structure \sphinxtitleref{S}.

\item {} 
\sphinxcode{\sphinxupquote{S = get\_data("FDSN", "HV.MOKD..HHZ", "IRIS", s="2012-01-01T00:00:00", t=(-3600))}}: using FDSNWS, fill a new SeisData structure \sphinxtitleref{S} with an hour of data ending at 2012-01-01, 00:00:00 UTC, from HV.MOKD..HHZ (USGS Hawai’i Volcano Observatory).

\end{enumerate}


\subsection{FDSN Queries}
\label{\detokenize{src/Web/webclients:fdsn-queries}}\phantomsection\label{\detokenize{src/Web/webclients:fdsnws}}
\sphinxhref{http://www.fdsn.org/}{The International Federation of Digital Seismograph Networks (FDSN)} is a global organization that supports seismology research. The FDSN web protocol offers near-real-time access to data from thousands of instruments across the world.

FDSN queries in SeisIO are highly customizable; see {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{data keywords list}}}} and {\hyperref[\detokenize{src/Appendices/web_syntax:cid}]{\sphinxcrossref{\DUrole{std,std-ref}{channel id syntax}}}}.


\subsubsection{Data Query}
\label{\detokenize{src/Web/webclients:data-query}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{get\_data!(S,~"FDSN",~channels;~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~get\_data("FDSN",~channels;~KWs)}}}
\end{fulllineitems}


FDSN data query with get\_data! wrapper.

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: fmt, nd, opts, rad, reg, s, si, t, to, v, w, y
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{s}}: Start time
\item[] \sphinxcode{\sphinxupquote{t}}: Termination (end) time
\item[] \sphinxcode{\sphinxupquote{xf}}: Name of XML file to save station metadata
\end{DUlineblock}


\subsubsection{Station Query}
\label{\detokenize{src/Web/webclients:station-query}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{FDSNsta!(S,~chans,~KW)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~FDSNsta(chans,~KW)}}}
\end{fulllineitems}


Fill channels \sphinxtitleref{chans} of SeisData structure \sphinxtitleref{S} with information retrieved from
remote station XML files by web query.

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: src, to, v
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{s}}: Start time
\item[] \sphinxcode{\sphinxupquote{t}}: Termination (end) time
\end{DUlineblock}


\subsection{IRIS Queries}
\label{\detokenize{src/Web/webclients:iris-queries}}\phantomsection\label{\detokenize{src/Web/webclients:irisws}}
Incorporated Research Institutions for Seismology \sphinxhref{http://www.iris.edu/}{(IRIS)} is a consortium of universities dedicated to the operation of science facilities for the acquisition, management, and distribution of seismological data.


\subsubsection{Data Query Features}
\label{\detokenize{src/Web/webclients:data-query-features}}\begin{itemize}
\item {} 
Stage zero gains are removed from trace data; all IRIS data will appear to have a gain of 1.0.

\item {} 
IRISWS disallows wildcards in channel IDs.

\item {} 
Channel spec \sphinxstyleemphasis{must} include the net, sta, cha fields; thus, CHA = “CC.VALT..BHZ” is OK; CHA = “CC.VALT” is not.

\end{itemize}


\section{SeedLink}
\label{\detokenize{src/Web/seedlink:seedlink}}\label{\detokenize{src/Web/seedlink:seedlink-section}}\label{\detokenize{src/Web/seedlink::doc}}
\sphinxhref{https://www.seiscomp3.org/wiki/doc/applications/seedlink}{SeedLink} is a
TCP/IP-based data transmission protocol that allows near-real-time access to
data from thousands of geophysical monitoring instruments. See
{\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{data keywords list}}}} and {\hyperref[\detokenize{src/Appendices/web_syntax:cid}]{\sphinxcrossref{\DUrole{std,std-ref}{channel id syntax}}}} for options.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{SeedLink!(S,~chans,~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{SeedLink!(S,~chans,~patts,~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~SeedLink(chans,~KWs)}}}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{chans}
\item[] Channel specification can use any of the following options:
\item[] 
\item[] 1. A comma-separated String where each pattern follows the syntax NET.STA.LOC.CHA.DFLAG, e.g. UW.TDH..EHZ.D. Use “?” to match any single character.
\item[] 2. An Array\{String,1\} with one pattern per entry, following the above syntax.
\item[] 3. The name of a configuration text file, with one channel pattern per line; see {\hyperref[\detokenize{src/Appendices/web_syntax:ccfg}]{\sphinxcrossref{\DUrole{std,std-ref}{Channel Configuration File syntax}}}}.
\item[] 
\item[] \sphinxstylestrong{patts}
\item[] Data selection patterns. See official SeedLink documentation; syntax is identical.
\item[] 
\item[] \sphinxstylestrong{KWs}
\item[] Keyword arguments; see also {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO standard KWs}}}} or type \sphinxcode{\sphinxupquote{?SeisIO.KW}}.
\item[] Standard keywords: fmt, opts, q, si, to, v, w, y
\item[] SL keywords: gap, kai, mode, port, refresh, safety, x\_on\_err
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

Initiate a SeedLink session in DATA mode to feed data from channels \sphinxcode{\sphinxupquote{chans}} with
selection patterns \sphinxcode{\sphinxupquote{patts}} to SeisData structure \sphinxcode{\sphinxupquote{S}}. A handle to a TCP
connection is appended to \sphinxcode{\sphinxupquote{S.c}}.Data are periodically parsed until the
connection is closed. One SeisData object can support multiple connections,
provided that each connection’s streams feed unique channels.


\subsection{Special Rules}
\label{\detokenize{src/Web/seedlink:special-rules}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} \begin{description}
\item[{SeedLink follows unusual rules for wild cards in \sphinxcode{\sphinxupquote{sta}} and \sphinxcode{\sphinxupquote{patts}}:}] \leavevmode\begin{enumerate}
\def\theenumii{\alph{enumii}}
\def\labelenumii{\theenumii .}
\makeatletter\def\p@enumiii{\p@enumii \theenumii .}\makeatother
\item {} 
\sphinxcode{\sphinxupquote{*}} is not a valid SeedLink wild card.

\item {} 
The LOC and CHA fields can be left blank in \sphinxcode{\sphinxupquote{sta}} to select all locations and channels.

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{DO NOT feed one data channel with multiple SeedLink streams. This can have severe consequences:}] \leavevmode\begin{enumerate}
\def\theenumii{\alph{enumii}}
\def\labelenumii{\theenumii .}
\makeatletter\def\p@enumiii{\p@enumii \theenumii .}\makeatother
\item {} 
A channel fed by multiple live streams will have many small time sequences out of order. \sphinxcode{\sphinxupquote{merge!}} is not guaranteed to fix it.

\item {} 
SeedLink will almost certainly crash.

\item {} 
Your data may be corrupted.

\item {} 
The Julia interpreter can freeze, requiring \sphinxcode{\sphinxupquote{kill -9}} on the process.

\item {} 
This is not an “issue”. There will never be a workaround. It’s what happens when one intentionally causes TCP congestion on one’s own machine while writing to open data streams in memory. Hint: don’t do this.

\end{enumerate}

\end{description}

\end{enumerate}


\subsection{Special Methods}
\label{\detokenize{src/Web/seedlink:special-methods}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{close(S.c{[}i{]})}} ends SeedLink connection \sphinxcode{\sphinxupquote{i}}.

\item {} 
\sphinxcode{\sphinxupquote{!deleteat(S.c, i)}} removes a handle to closed SeedLink connection \sphinxcode{\sphinxupquote{i}}.

\end{itemize}


\subsubsection{SeedLink Utilities}
\label{\detokenize{src/Web/seedlink:seedlink-utilities}}\index{SL\_info() (built-in function)@\spxentry{SL\_info()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Web/seedlink:SL_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SL\_info}}}{\emph{v}, \emph{url}}{}
\end{fulllineitems}


Retrieve SeedLink information at verbosity level \sphinxstylestrong{v} from \sphinxstylestrong{url}. Returns XML as a string. Valid strings for \sphinxstylestrong{L} are ID, CAPABILITIES, STATIONS, STREAMS, GAPS, CONNECTIONS, ALL.
\index{has\_sta() (built-in function)@\spxentry{has\_sta()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Web/seedlink:has_sta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_sta}}}{\emph{sta}\sphinxoptional{, \emph{u=url}, \emph{port=n}}}{}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] SL keywords: gap, port
\item[] Other keywords: \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

Check that streams exist at \sphinxtitleref{url} for stations \sphinxtitleref{sta}, formatted
NET.STA. Use “?” to match any single character. Returns true for
stations that exist. \sphinxtitleref{sta} can also be the name of a valid config
file or a 1d string array.

Returns a BitArray with one value per entry in \sphinxtitleref{sta.}
\index{has\_stream() (built-in function)@\spxentry{has\_stream()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Web/seedlink:has_stream}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_stream}}}{\emph{cha::Union\{String}, \emph{Array\{String}, \emph{1\}\}}, \emph{u::String}}{}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] SL keywords: gap, port
\item[] Other keywords: \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

Check that streams with recent data exist at url \sphinxtitleref{u} for channel spec
\sphinxtitleref{cha}, formatted NET.STA.LOC.CHA.DFLAG, e.g. “UW.TDH..EHZ.D,
CC.HOOD..BH?.E”. Use “?” to match any single character. Returns \sphinxtitleref{true}
for streams with recent data.

\sphinxtitleref{cha} can also be the name of a valid config file.


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_stream}}}{\emph{sta::Array\{String}, \emph{1\}}, \emph{sel::Array\{String}, \emph{1\}}, \emph{u::String}, \emph{port=N::Int}, \emph{gap=G::Real}}{}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] SL keywords: gap, port
\item[] Other keywords: \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

If two arrays are passed to has\_stream, the first should be
formatted as SeedLink STATION patterns (formated “SSSSS NN”, e.g.
{[}“TDH UW”, “VALT CC”{]}); the second be an array of SeedLink selector
patterns (formatted LLCCC.D, e.g. {[}“??EHZ.D”, “??BH?.?”{]}).


\chapter{Processing}
\label{\detokenize{index:processing}}
Supported processing operations are described below.

In most cases, a “safe” version of each function can be invoked to create a
new object with the processed output.

Any function that can logically operate on a single-channel object will do so. Any
function that operates on a SeisData object can be applied to the :data field of a
SeisEvent object.


\section{Basic Functions}
\label{\detokenize{src/Processing/processing:basic-functions}}\label{\detokenize{src/Processing/processing::doc}}
These functions have no keywords that fundamentally change their behavior.

Remove the mean from all channels i with S.fs{[}i{]} \textgreater{} 0.0. Specify irr=true to also
remove the mean from irregularly sampled channels. Specify chans=CC to restrict
to channel number(s) CC. Ignores NaNs.

Remove the polynomial trend of degree n from every regularly-sampled channel
in S using a least-squares polynomial fit. Specify chans=CC to restrict
to channel number(s) CC. Ignores NaNs.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{nanfill!(S)}}}
\end{fulllineitems}


For each channel \sphinxstylestrong{i} in \sphinxstylestrong{S}, replace all NaNs in \sphinxstylestrong{S.x{[}i{]}} with the mean
of non-NaN values.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{resample!(S::GphysData~{[},~chans=CC,~fs=FS{]})}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{resample!(C::SeisChannel,~fs::Float64)}}}
\end{fulllineitems}


Resample data in S to FS Hz. If keyword \sphinxstylestrong{fs} is not specified, data are
resampled to the lowest non-zero value in \sphinxstylestrong{S.fs{[}CC{]}}. Note that a poor choice
of fs can lead to upsampling and other bad behaviors.

Use keyword \sphinxstylestrong{chans=CC} to only resample channel numbers \sphinxstylestrong{CC}. By default,
all channels \sphinxstylestrong{i} with \sphinxstylestrong{S.fs{[}i{]} \textgreater{} 0.0} are resampled.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{unscale!(S{[},~chans=CC,~irr=false{]})}}}
\end{fulllineitems}


Divide the gains from all channels \sphinxstylestrong{i} with \sphinxstylestrong{S.fs{[}i{]} \textgreater{} 0.0}. Specify
chans=CC to restrict to channel number(s) CC. Specify \sphinxstylestrong{irr=true} to also
remove gains of irregularly-sampled channels.


\section{Customizable Functions}
\label{\detokenize{src/Processing/processing:customizable-functions}}

\subsection{Convert Seismograms}
\label{\detokenize{src/Processing/processing:convert-seismograms}}
Seismograms can be converted to or from displacement, velocity, or acceleration
using convert\_seis:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{convert\_seis!(S{[},~chans=CC,~units\_out=UU,~v=V{]})}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{convert\_seis!(C{[},~units\_out=UU,~v=V{]})}}}
\end{fulllineitems}


Converts all seismic data channels in \sphinxtitleref{S} to velocity seismograms,
differentiating or integrating as needed.


\subsubsection{Keywords}
\label{\detokenize{src/Processing/processing:keywords}}\begin{itemize}
\item {} 
units\_out=UU: specify output units: “m”, “m/s” (default), or “m/s\(\sp{\text{2}}\)”

\item {} 
chans=CC: restrict seismogram conversion to seismic data channels in CC

\item {} 
v=V: verbosity

\end{itemize}


\paragraph{Behavior and Usage Warnings}
\label{\detokenize{src/Processing/processing:behavior-and-usage-warnings}}
\sphinxstylestrong{Long Seismograms}: convert\_seis becomes less reversible as seismograms lengthen,
especially at Float32 precision, due to \sphinxhref{https://en.wikipedia.org/wiki/Floating-point\_arithmetic\#Accuracy\_problems}{loss of significance}.
At single (Float32) precision, seismograms with N \textasciitilde{} 10\textasciicircum{}6 samples are
reconstructable after one conversion (e.g. “m” ==\textgreater{} “m/s” can be reversed, with
output approximately equal to the original data). After multiple conversions
(i.e., “m” ==\textgreater{} “m/s\(\sp{\text{2}}\)” or “m/s\(\sp{\text{2}}\)” ==\textgreater{} “m”), Float32 data cannot be perfectly
reconstructed in this way, though reconstruction errors are typically small.

\sphinxstylestrong{Rectangular Integration}: integration is always rectangular; irregularly-spaced
seismic data are not processed by convert\_seis. Summation uses an in-place
variant of \sphinxhref{https://github.com/JuliaMath/KahanSummation.jl}{Kahan-Babuška-Neumaier summation}.


\bigskip\hrule\bigskip



\subsection{Fill Gaps}
\label{\detokenize{src/Processing/processing:fill-gaps}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{ungap!(S{[},~chans=CC,~m=true,~tap=false{]})}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{ungap!(C{[},~m=true,~tap=false{]})}}}
\end{fulllineitems}


Fill time gaps in each channel with the mean of the channel data.


\subsubsection{Keywords}
\label{\detokenize{src/Processing/processing:id1}}\begin{itemize}
\item {} 
chans=CC: only ungap channels CC.

\item {} 
m=false: this flag fills gaps with NaNs instead of the mean.

\item {} 
tap=true: taper data before filling gaps.

\end{itemize}


\bigskip\hrule\bigskip



\subsection{Merge}
\label{\detokenize{src/Processing/processing:merge}}\label{\detokenize{src/Processing/processing:id2}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{merge!(S::GphysData,~U::GphysData)}}}
\end{fulllineitems}


Merge two GphysData structures. For timeseries data, a single-pass merge-and-prune
operation is applied to value pairs whose sample times are separated by less than
half the sampling interval.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{merge!(S::GphysData)}}}
\end{fulllineitems}


“Flatten” a GphysData structure by merging data from identical channels.


\subsubsection{Merge Behavior}
\label{\detokenize{src/Processing/processing:merge-behavior}}

\paragraph{Which channels merge?}
\label{\detokenize{src/Processing/processing:which-channels-merge}}\begin{itemize}
\item {} 
Channels merge if they have identical values for \sphinxcode{\sphinxupquote{:id}}, \sphinxcode{\sphinxupquote{:fs}}, \sphinxcode{\sphinxupquote{:loc}}, \sphinxcode{\sphinxupquote{:resp}}, and \sphinxcode{\sphinxupquote{:units}}.

\item {} 
An unset \sphinxcode{\sphinxupquote{:loc}}, \sphinxcode{\sphinxupquote{:resp}}, or \sphinxcode{\sphinxupquote{:units}} field matches any set value in the corresponding field of another channel.

\end{itemize}


\paragraph{What happens to merged fields?}
\label{\detokenize{src/Processing/processing:what-happens-to-merged-fields}}\begin{itemize}
\item {} 
The essential properties above are preserved.

\item {} 
Other fields are combined.

\item {} 
Merged channels with different \sphinxtitleref{:name} values use the name of the channel with the latest data before the merge; other names are logged to \sphinxtitleref{:notes}.

\end{itemize}


\paragraph{What does \sphinxstyleliteralintitle{\sphinxupquote{merge!}} resolve?}
\label{\detokenize{src/Processing/processing:what-does-merge-resolve}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{2}|\X{1}{2}|}
\hline
\sphinxstyletheadfamily 
Issue
&\sphinxstyletheadfamily 
Resolution
\\
\hline
Empty channels
&
Delete
\\
\hline
Duplicated channels
&
Delete duplicate channels
\\
\hline
Duplicated windows in channel(s)
&
Delete duplicate windows
\\
\hline
Multiple channels, same properties$^{\text{(a)}}$
&
Merge to a single channel
\\
\hline
Channel with out-of-order time windows
&
Sort in chronological order
\\
\hline
Overlapping windows, identical data, time-aligned
&
Windows merged
\\
\hline
Overlapping windows, identical data, small time offset$^{\text{(a)}}$
&
Time offset corrected, windows merged
\\
\hline
Overlapping windows, non-identical data
&
Samples averaged, windows merged
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

$^{\text{(a)}}$ “Properties” here are \sphinxcode{\sphinxupquote{:id}}, \sphinxcode{\sphinxupquote{:fs}}, \sphinxcode{\sphinxupquote{:loc}}, \sphinxcode{\sphinxupquote{:resp}}, and \sphinxcode{\sphinxupquote{:units}}.
$^{\text{(b)}}$ Data offset \textgreater{}4 sample intervals are treated as overlapping and non-identical.


\paragraph{When SeisIO Won’t Merge}
\label{\detokenize{src/Processing/processing:when-seisio-won-t-merge}}
SeisIO does \sphinxstylestrong{not} combine data channels if \sphinxstylestrong{any} of the five fields above
are non-empty and different. For example, if a GphysData object S contains two
channels, each with id “XX.FOO..BHZ”, but one has fs=100 Hz and the other fs=50 Hz,
\sphinxstylestrong{merge!} does nothing.

It’s best to merge only unprocessed data. Data segments that were processed
independently (e.g. detrended) will be averaged pointwise when merged, which
can easily leave data in an unusuable state.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{mseis!(S::GphysData,~U::GphysData,~...)}}}
\end{fulllineitems}


Merge multiple GphysData structures into S.


\bigskip\hrule\bigskip



\subsection{Seismic Instrument Response}
\label{\detokenize{src/Processing/processing:seismic-instrument-response}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{translate\_resp!(S,~resp\_new{[},~chans=CC,~wl=g{]})}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{translate\_resp!(Ch,~resp\_new{[},~wl=g{]})}}}
\end{fulllineitems}


Translate the instrument response of seismic data channels to \sphinxstylestrong{resp\_new}.
Replaces field \sphinxstylestrong{:resp} with \sphinxstylestrong{resp\_new} for all affected channels.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{remove\_resp!(S,~chans=CC,~wl=g{]})}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{remove\_resp!(Ch,~wl=g{]})}}}
\end{fulllineitems}


Remove (flatten to DC) the instrument response of \sphinxstylestrong{Ch}, or of seismic data
channels \sphinxstylestrong{CC} in \sphinxstylestrong{S}. Replaces \sphinxstylestrong{:resp} with the appropriate (all-pass)
response.


\subsubsection{Keywords}
\label{\detokenize{src/Processing/processing:id3}}\begin{itemize}
\item {} 
\sphinxstylestrong{C=cha} restricts response translation for GphysData object \sphinxstylestrong{S} to channel(s) \sphinxstylestrong{cha}. Accepts an Integer, UnitRange, or Array\{Int64,1\} argument; does \sphinxstyleemphasis{not} accept string IDs. By default, all seismic data channels in \sphinxstylestrong{S} have their responses translated to \sphinxstylestrong{resp\_new}.

\item {} 
\sphinxstylestrong{wl=g} sets the waterlevel to g (default: g = eps(Float32) \textasciitilde{} 1.1f-7). The waterlevel is the minimum magnitude (absolute value) of the normalized old frequency response; in other words, if the old frequency response has a maximum magnitude of 1.0, then no response coefficient can be lower than g. This is useful to prevent “divide by zero” errors, but setting it too high will cause errors.

\end{itemize}


\subsubsection{Precision and Memory Optimization}
\label{\detokenize{src/Processing/processing:precision-and-memory-optimization}}
To optimize speed and memory use, instrument response translation maps data to
Complex\{Float32\} before translation; thus, with Float64 data, there can be
minor rounding errors.

Instrument responses are also memory-intensive. The minimum memory consumption
to translate the response of a gapless Float32 SeisChannel object is \textasciitilde{}7x the
size of the object itself.

More precisely, for an object \sphinxstylestrong{S} (of Type \textless{}: GphysData or GphysChannel),
translation requires memory \textasciitilde{} 2 kB + the greater of (7x the size of the longest
Float32 segment, or 3.5x the size of the longest Float64 segment). Translation
uses four vectors \textendash{} three complex and one real \textendash{} that are updated and
dynamically resized as the algorithm loops over each segment:
\begin{itemize}
\item {} 
Old response container: Array\{Complex\{Float32,1\}\}(undef, Nx)

\item {} 
New response container: Array\{Complex\{Float32,1\}\}(undef, Nx)

\item {} 
Complex data container: Array\{Complex\{Float32,1\}\}(undef, Nx)

\item {} 
Real frequencies for FFT: Array\{Float32,1\}(undef, Nx)

\end{itemize}

…where \sphinxstylestrong{Nx} is the number of samples in the longest segment in \sphinxstylestrong{S}.


\bigskip\hrule\bigskip



\subsection{Synchronize}
\label{\detokenize{src/Processing/processing:synchronize}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{sync!(S::GphysData)}}}
\end{fulllineitems}


Synchronize the start times of all data in S to begin at or after the last
start time in S.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{sync!(S::GphysData{[},~s=ST,~t=EN,~v=VV{]})}}}
\end{fulllineitems}


Synchronize all data in S to start at \sphinxtitleref{ST} and terminate at \sphinxtitleref{EN} with verbosity level VV.

For regularly-sampled channels, gaps between the specified and true times
are filled with the mean; this isn’t possible with irregularly-sampled data.


\subsubsection{Specifying start time (s)}
\label{\detokenize{src/Processing/processing:specifying-start-time-s}}\begin{itemize}
\item {} 
s=”last”: (Default) sync to the last start time of any channel in \sphinxtitleref{S}.

\item {} 
s=”first”: sync to the first start time of any channel in \sphinxtitleref{S}.

\item {} 
A numeric value is treated as an epoch time (\sphinxtitleref{?time} for details).

\item {} 
A DateTime is treated as a DateTime. (see Dates.DateTime for details.)

\item {} 
Any string other than “last” or “first” is parsed as a DateTime.

\end{itemize}


\subsubsection{Specifying end time (t)}
\label{\detokenize{src/Processing/processing:specifying-end-time-t}}\begin{itemize}
\item {} 
t=”none”: (Default) end times are not synchronized.

\item {} 
t=”last”: synchronize all channels to end at the last end time in \sphinxtitleref{S}.

\item {} 
t=”first” synchronize to the first end time in \sphinxtitleref{S}.

\item {} 
numeric, datetime, and non-reserved strings are treated as for \sphinxtitleref{-s}.

\end{itemize}


\bigskip\hrule\bigskip



\subsection{Taper}
\label{\detokenize{src/Processing/processing:taper}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{taper!(S{[},~chans=CC,~t\_max::Real=10.0,~:math:{}`alpha{}`::Real=0.05,~N\_min::Int64=10{]})}}}
\end{fulllineitems}


Cosine taper each channel in S around time gaps. Specify chans=CC to restrict
to channel number(s) CC. Does not modify irregularly-sampled data channels.

taper!(C{[}, t\_max::Real=10.0, \(\alpha\)::Real=0.05, N\_min::Int64=10{]})

Cosine taper each segment of time-series data in GphysChannel object C that
contains at least \sphinxtitleref{N\_min} total samples. Returns if C is irregularly sampled.


\subsubsection{Keywords}
\label{\detokenize{src/Processing/processing:id4}}\begin{itemize}
\item {} 
chans: Only taper the specified channels.

\item {} 
N\_min: Data segments with N \textless{} N\_min total samples are not tapered.

\item {} 
t\_max: Maximum taper edge in seconds.

\item {} 
\(\alpha\): Taper edge area; as for a Tukey window, the first and last 100*:math:\sphinxtitleref{alpha{}`\% of samples in each window are tapered, up to {}`t\_max} seconds of data.

\end{itemize}


\bigskip\hrule\bigskip



\subsection{Zero-Phase Filter}
\label{\detokenize{src/Processing/processing:zero-phase-filter}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{filtfilt!(S::GphysData{[};~KWs{]})}}}
\end{fulllineitems}


Apply a zero-phase filter to regularly-sampled data in \sphinxstylestrong{S}. Irregularly-sampled data are never processed by filtfilt!.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{filtfilt!(C::SeisChannel{[};~KWs{]})}}}
\end{fulllineitems}


Apply zero-phase filter to \sphinxstylestrong{C.x}. Filtering is applied to each contiguous data
segment in C separately.


\subsubsection{Keywords}
\label{\detokenize{src/Processing/processing:id5}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{8}|\X{2}{8}|\X{1}{8}|\X{4}{8}|}
\hline
\sphinxstyletheadfamily 
KW
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
chans
&
{[}{]}
&
$^{\text{(a)}}$
&
channel numbers to filter
\\
\hline
fl
&
1.0
&
Float64
&
lower corner frequency {[}Hz{]} $^{\text{(b)}}$
\\
\hline
fh
&
15.0
&
Float64
&
upper corner frequency {[}Hz{]} $^{\text{(b)}}$
\\
\hline
np
&
4
&
Int64
&
number of poles
\\
\hline
rp
&
10
&
Int64
&
pass-band ripple (dB)
\\
\hline
rs
&
30
&
Int64
&
stop-band ripple (dB)
\\
\hline
rt
&
“Bandpass”
&
String
&
response type (type of filter)
\\
\hline
dm
&
“Butterworth”
&
String
&
design mode (name of filter)
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

$^{\text{(a)}}$  Allowed types are Integer, UnitRange, and Array\{Int64, 1\}.
$^{\text{(b)}}$  By convention, the lower corner frequency (fl) is used in a Highpass
filter, and fh is used in a Lowpass filter.

Default filtering KW values can be changed by adjusting the {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{shared keywords}}}},
e.g., SeisIO.KW.Filt.np = 2 changes the default number of poles to 2.


\chapter{Submodules}
\label{\detokenize{index:submodules}}

\section{Quake}
\label{\detokenize{src/Submodules/quake:quake}}\label{\detokenize{src/Submodules/quake::doc}}
The Quake submodule (accessed with “using SeisIO.Quake”) was introduced in
SeisIO v0.3.0 to isolate handling of discrete earthquake events from handling
of continuous geophysical data. While the channel data are similar, fully
describing an earthquake event requires many additional Types (objects) and
more information (fields) in channel descriptors.


\subsection{Types}
\label{\detokenize{src/Submodules/quake:types}}
See Type help text for field descriptions and SeisIO behavior.
\index{EQMag() (built-in function)@\spxentry{EQMag()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:EQMag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{EQMag}}}{}{}
\end{fulllineitems}


Earthquake magnitude object.
\index{EQLoc() (built-in function)@\spxentry{EQLoc()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:EQLoc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{EQLoc}}}{}{}
\end{fulllineitems}


Computed earthquake location.
\index{EventChannel() (built-in function)@\spxentry{EventChannel()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:EventChannel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{EventChannel}}}{}{}
\end{fulllineitems}


A single channel of trace data (digital seismograms) associated with a
discrete event (earthquake).
\index{EventTraceData() (built-in function)@\spxentry{EventTraceData()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:EventTraceData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{EventTraceData}}}{}{}
\end{fulllineitems}


A custom structure designed to describe trace data (digital seismograms)
associated with a discrete event (earthquake).
\index{PhaseCat() (built-in function)@\spxentry{PhaseCat()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:PhaseCat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PhaseCat}}}{}{}
\end{fulllineitems}


A seismic phase catalog is a dictionary with phase names for keys (e.g. “pP”, “PKP”)
and SeisPha objects for values.
\index{SeisEvent() (built-in function)@\spxentry{SeisEvent()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:SeisEvent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SeisEvent}}}{}{}
\end{fulllineitems}


A compound Type comprising a SeisHdr (event header), SeisSrc (source process),
and EventTraceData (digital seismograms.)
\index{SeisHdr() (built-in function)@\spxentry{SeisHdr()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:SeisHdr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SeisHdr}}}{}{}
\end{fulllineitems}


Earthquake event header object.
\index{SeisPha() (built-in function)@\spxentry{SeisPha()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:SeisPha}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SeisPha}}}{}{}
\end{fulllineitems}


A description of a seismic phase measured on a data channel.
\index{SeisSrc() (built-in function)@\spxentry{SeisSrc()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:SeisSrc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SeisSrc}}}{}{}
\end{fulllineitems}


Seismic source process description.
\index{SourceTime() (built-in function)@\spxentry{SourceTime()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:SourceTime}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SourceTime}}}{}{}
\end{fulllineitems}


QuakeML-compliant seismic source-time parameterization.


\subsection{Web Queries}
\label{\detokenize{src/Submodules/quake:web-queries}}

\subsubsection{Event Header Query}
\label{\detokenize{src/Submodules/quake:event-header-query}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{FDSNevq}}}{\emph{ot}}{}
\end{fulllineitems}


{\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: evw, rad, reg, mag, nev, src, to, v, w

Multi-server query for the event(s) with origin time(s) closest to \sphinxtitleref{ot}. Returns
a tuple consisting of an Array\{SeisHdr,1\} and an Array\{SeisSrc,1\}, so that
the \sphinxtitleref{i{}`th entry of each array describes the header and source process of event {}`i}.

Notes:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Specify \sphinxtitleref{ot} as a string formatted YYYY-MM-DDThh:mm:ss in UTC (e.g. “2001-02-08T18:54:32”). Returns a SeisHdr array.

\item {} 
Incomplete string queries are read to the nearest fully-specified time constraint; thus, \sphinxtitleref{FDSNevq(“2001-02-08”)} returns the nearest event to 2001-02-08T00:00:00.

\item {} 
If no event is found in the specified search window, FDSNevq exits with an error.

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: evw, reg, mag, nev, src, to, w
\end{DUlineblock}


\subsubsection{Event Header and Data Query}
\label{\detokenize{src/Submodules/quake:event-header-and-data-query}}\index{FDSNevt() (built-in function)@\spxentry{FDSNevt()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:FDSNevt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{FDSNevt}}}{\emph{ot::String}, \emph{chans::String}}{}
\end{fulllineitems}


Get trace data for the event closest to origin time \sphinxtitleref{ot} on channels \sphinxtitleref{chans}.
Returns a SeisEvent.

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: fmt, mag, nd, opts, pha, rad, reg, src, to, v, w
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{len}}: desired record length \sphinxstyleemphasis{in minutes}.
\end{DUlineblock}


\subsubsection{Phase Onset Query}
\label{\detokenize{src/Submodules/quake:phase-onset-query}}\index{get\_pha() (built-in function)@\spxentry{get\_pha()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:get_pha}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_pha}}}{\emph{:math:{}`Delta{}`::Float64}, \emph{z::Float64}}{}
\end{fulllineitems}


Command-line interface to IRIS online implementation of the TauP travel time
calculator {[}1-2{]}. Returns a matrix of strings. Specify \(\Delta\) in decimal degrees
and z in km with + = down.

\begin{DUlineblock}{0em}
\item[] Shared keywords keywords: pha, to, v
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{-model}}: velocity model (defaults to “iasp91”)
\end{DUlineblock}

\sphinxstylestrong{References}
\begin{itemize}
\item {} 
Crotwell, H. P., Owens, T. J., \& Ritsema, J. (1999). The TauP Toolkit: Flexible seismic travel-time and ray-path utilities, SRL 70(2), 154-160.

\item {} 
TauP manual: \sphinxurl{http://www.seis.sc.edu/downloads/TauP/taup.pdf}

\end{itemize}


\subsection{QuakeML Reader}
\label{\detokenize{src/Submodules/quake:quakeml-reader}}\index{read\_qml() (built-in function)@\spxentry{read\_qml()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:read_qml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_qml}}}{\emph{fpat::String}}{}
\end{fulllineitems}


Read QuakeML files matching string pattern \sphinxstylestrong{fpat}. Returns a tuple containing
an array of \sphinxstylestrong{SeisHdr} objects \sphinxstylestrong{H} and an array of \sphinxstylestrong{SeisSrc} objects \sphinxstylestrong{R}.
Each pair (H{[}i{]}, R{[}i{]}) describes the preferred location (origin, SeisHdr) and
event source (focal mechanism or moment tensor, SeisSrc) of event \sphinxstylestrong{i}.

If multiple focal mechanisms, locations, or magnitudes are present in a single
Event element of the XML file(s), the following rules are used to select one of
each per event:

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{FocalMechanism}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1. \sphinxstylestrong{preferredFocalMechanismID} if present
\item[] 2. Solution with best-fitting moment tensor
\item[] 3. First \sphinxstylestrong{FocalMechanism} element
\item[] 
\end{DUlineblock}
\item[] \sphinxstylestrong{Magnitude}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1. \sphinxstylestrong{preferredMagnitudeID} if present
\item[] 2. Magnitude whose ID matches \sphinxstylestrong{MomentTensor/derivedOriginID}
\item[] 3. Last moment magnitude (lowercase scale name begins with “mw”)
\item[] 4. First \sphinxstylestrong{Magnitude} element
\item[] 
\end{DUlineblock}
\item[] \sphinxstylestrong{Origin}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1. \sphinxstylestrong{preferredOriginID} if present
\item[] 2. \sphinxstylestrong{derivedOriginID} from the chosen \sphinxstylestrong{MomentTensor} element
\item[] 3. First \sphinxstylestrong{Origin} element
\end{DUlineblock}
\end{DUlineblock}

Non-essential QuakeML data are saved to \sphinxtitleref{misc} in each SeisHdr or SeisSrc object
as appropriate.


\subsection{File Readers}
\label{\detokenize{src/Submodules/quake:file-readers}}\index{uwpf() (built-in function)@\spxentry{uwpf()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:uwpf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uwpf}}}{\emph{pf}\sphinxoptional{, \emph{v}}}{}
\end{fulllineitems}


Read UW-format seismic pick file \sphinxtitleref{pf}. Returns a tuple of (SeisHdr, SeisSrc).


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{uwpf!(W,~pf{[},~v::Int64=KW.v{]})}}}
\end{fulllineitems}


Read UW-format seismic pick info from pickfile \sphinxtitleref{f} into SeisEvent object \sphinxtitleref{W}.
Overwrites W.source and W.hdr with pickfile information. Keyword \sphinxtitleref{v} controls
verbosity.
\index{readuwevt() (built-in function)@\spxentry{readuwevt()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:readuwevt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{readuwevt}}}{\emph{fpat}}{}
Read University of Washington-format event data with file pattern stub fpat
into a SeisEvent object. \sphinxcode{\sphinxupquote{fpat}} can be a datafile name, a pickfile name, or
a stub.

\end{fulllineitems}



\subsection{Utility Functions}
\label{\detokenize{src/Submodules/quake:utility-functions}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{distaz!(Ev::SeisEvent)}}}
\end{fulllineitems}


Compute distnace, azimuth, and backazimuth by the Haversine formula.
Overwrites Ev.data.dist, Ev.data.az, and Ev.data.baz.
\index{gcdist() (built-in function)@\spxentry{gcdist()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:gcdist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gcdist}}}{\sphinxoptional{\emph{lat\_src}, \emph{lon\_src}}, \emph{rec}}{}
\end{fulllineitems}


Compute great circle distance, azimuth, and backazimuth from a single source
with coordinates \sphinxtitleref{{[}s\_lat, s\_lon{]}} to receivers \sphinxtitleref{rec} with coordinates
\sphinxtitleref{{[}r\_lat r\_lon{]}} in each row.
\index{show\_phases() (built-in function)@\spxentry{show\_phases()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/quake:show_phases}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{show\_phases}}}{\emph{P::PhaseCat}}{}
\end{fulllineitems}


Formatted display of seismic phases in dictionary P.


\section{RandSeis}
\label{\detokenize{src/Submodules/randseis:randseis}}\label{\detokenize{src/Submodules/randseis::doc}}
This submodule is used to quickly generate SeisIO objects with quasi-random
field contents. Access it with “using SeisIO.RandSeis”

The following are true of all random data objects generated by the RandSeis
module:
\begin{itemize}
\item {} 
Channels have SEED-compliant IDs, sampling frequencies, and data types.

\item {} 
Random junk fills :notes and :misc.

\item {} 
Sampling frequency (:fs) is chosen from a set of common values.

\item {} 
Channel data are randomly generated.

\item {} 
Time gaps are automatically inserted into regularly-sampled data.

\end{itemize}
\index{randPhaseCat() (built-in function)@\spxentry{randPhaseCat()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/randseis:randPhaseCat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randPhaseCat}}}{}{}
\end{fulllineitems}


Generate a random seismic phase catalog suitable for testing EventChannel,
EventTraceData, and SeisEvent objects.
\index{randSeisChannel() (built-in function)@\spxentry{randSeisChannel()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/randseis:randSeisChannel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisChannel}}}{\sphinxoptional{\emph{c=false}, \emph{s=false}}}{}
\end{fulllineitems}


Generate a SeisChannel of random data. Specify c=true for campaign-style
(irregularly-sampled) data (fs = 0.0); specify s=true to guarantee seismic data.
s=true overrides c=true.
\index{randSeisData() (built-in function)@\spxentry{randSeisData()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/randseis:randSeisData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisData}}}{\sphinxoptional{\emph{c=0.2}, \emph{s=0.6}}}{}
\end{fulllineitems}


Generate 8 to 24 channels of random seismic data as a SeisData object.
\begin{itemize}
\item {} 
100*c\% of channels \sphinxstyleemphasis{after the first} will have irregularly-sampled data (fs = 0.0)

\item {} 
100*s\% of channels \sphinxstyleemphasis{after the first} are guaranteed to have seismic data.

\end{itemize}


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisData}}}{\emph{N}\sphinxoptional{, \emph{c=0.2}, \emph{s=0.6}}}{}
\end{fulllineitems}


Generate N channels of random seismic data as a SeisData object.
\index{randSeisEvent() (built-in function)@\spxentry{randSeisEvent()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/randseis:randSeisEvent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisEvent}}}{\sphinxoptional{\emph{c=0.2}, \emph{s=0.6}}}{}
\end{fulllineitems}


Generate a SeisEvent structure filled with random values.
\begin{itemize}
\item {} 
100*c\% of channels \sphinxstyleemphasis{after the first} will have irregularly-sampled data (fs = 0.0)

\item {} 
100*s\% of channels \sphinxstyleemphasis{after the first} are guaranteed to have seismic data.

\end{itemize}


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisEvent}}}{\emph{N}\sphinxoptional{, \emph{c=0.2}, \emph{s=0.6}}}{}
\end{fulllineitems}


Generate a random SeisEvent object with N channels of data.
\index{randSeisHdr() (built-in function)@\spxentry{randSeisHdr()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/randseis:randSeisHdr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisHdr}}}{}{}
\end{fulllineitems}


Generate a SeisHdr structure filled with random values.
\index{randSeisSrc() (built-in function)@\spxentry{randSeisSrc()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Submodules/randseis:randSeisSrc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisSrc}}}{}{}
\end{fulllineitems}


Generate a SeisSrc structure filled with random values.


\chapter{Appendices}
\label{\detokenize{index:appendices}}

\section{Utility Functions}
\label{\detokenize{src/Appendices/function_list:utility-functions}}\label{\detokenize{src/Appendices/function_list:function-list}}\label{\detokenize{src/Appendices/function_list::doc}}
This appendix covers utility functions that belong in no other category.
\index{d2u() (built-in function)@\spxentry{d2u()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:d2u}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{d2u}}}{\emph{DT::DateTime}}{}
\end{fulllineitems}


Aliased to \sphinxcode{\sphinxupquote{Dates.datetime2unix}}.

Keyword \sphinxcode{\sphinxupquote{hc\_new}} specifies the new critical damping constant. Keyword \sphinxcode{\sphinxupquote{C}} specifies an array of channel numbers on which to operate; by default, every channel with fs \textgreater{} 0.0 is affected.
\index{fctopz() (built-in function)@\spxentry{fctopz()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:fctopz}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fctopz}}}{\emph{fc}}{}
\end{fulllineitems}


Convert critical frequency \sphinxcode{\sphinxupquote{fc}} to a matrix of complex poles and zeros; zeros in \sphinxcode{\sphinxupquote{resp{[}:,1{]}}}, poles in \sphinxcode{\sphinxupquote{resp{[}:,2{]}}}.
\index{find\_regex() (built-in function)@\spxentry{find\_regex()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:find_regex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{find\_regex}}}{\emph{path::String}, \emph{r::Regex}}{}
\end{fulllineitems}


OS-agnostic equivalent to Linux \sphinxtitleref{find}. First argument is a path string, second is a Regex. File strings are postprocessed using Julia’s native PCRE Regex engine. By design, \sphinxtitleref{find\_regex} only returns file names.
\index{getbandcode() (built-in function)@\spxentry{getbandcode()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:getbandcode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getbandcode}}}{\emph{fs}, \emph{fc=FC}}{}
\end{fulllineitems}


Get SEED-compliant one-character band code corresponding to instrument sample rate \sphinxcode{\sphinxupquote{fs}} and corner frequency \sphinxcode{\sphinxupquote{FC}}. If unset, \sphinxcode{\sphinxupquote{FC}} is assumed to be 1 Hz.
\index{ls() (built-in function)@\spxentry{ls()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:ls}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ls}}}{\emph{s::String}}{}
\end{fulllineitems}


Similar functionality to Bash ls with OS-agnostic output. Accepts wildcards in paths and file names.
* Always returns the full path and file name.
* Partial file name wildcards (e.g. “\sphinxtitleref{ls(data/2006*.sac)}) invoke \sphinxtitleref{glob}.
* Path wildcards (e.g. \sphinxtitleref{ls(/data/*/*.sac)}) invoke \sphinxtitleref{find\_regex} to circumvent glob limitations.
* Passing ony “*” as a filename (e.g. “\sphinxtitleref{ls(/home/*)}) invokes \sphinxtitleref{find\_regex} to recursively search subdirectories, as in the Bash shell.
\index{ls() (built-in function)@\spxentry{ls()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ls}}}{}{}
\end{fulllineitems}


Return full path and file name of files in current working directory.
\index{j2md() (built-in function)@\spxentry{j2md()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:j2md}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{j2md}}}{\emph{y}, \emph{j}}{}
\end{fulllineitems}


Convert Julian day \sphinxstylestrong{j} of year \sphinxstylestrong{y} to month, day.
\index{md2j() (built-in function)@\spxentry{md2j()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:md2j}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{md2j}}}{\emph{y}, \emph{m}, \emph{d}}{}
\end{fulllineitems}


Convert month \sphinxstylestrong{m}, day \sphinxstylestrong{d} of year \sphinxstylestrong{y} to Julian day \sphinxstylestrong{j}.

Remove unwanted characters from S.
\index{parsetimewin() (built-in function)@\spxentry{parsetimewin()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:parsetimewin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parsetimewin}}}{\emph{s}, \emph{t}}{}
\end{fulllineitems}


Convert times \sphinxstylestrong{s} and \sphinxstylestrong{t} to strings \(\alpha, \omega\) sorted \(\alpha < \omega\).
\sphinxstylestrong{s} and \sphinxstylestrong{t} can be real numbers, DateTime objects, or ASCII strings.
Expected string format is “yyyy-mm-ddTHH:MM:SS.nnn”, e.g. 2016-03-23T11:17:00.333.

“Safe” synchronize of start and end times of all trace data in SeisData structure \sphinxcode{\sphinxupquote{S}} to a new structure \sphinxcode{\sphinxupquote{U}}.
\index{u2d() (built-in function)@\spxentry{u2d()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:u2d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{u2d}}}{\emph{x}}{}
\end{fulllineitems}


Alias to \sphinxcode{\sphinxupquote{Dates.unix2datetime}}.

function:: w\_time(W::Array\{Int64,2\}, fs::Float64)

Convert matrix W from time windows (w{[}:,1{]}:w{[}:,2{]}) in integer \(\mu s\) from the Unix epoch (1970-01-01T00:00:00) to sparse delta-encoded time representation. Specify fs in Hz.


\section{SeisIO Write Formats}
\label{\detokenize{src/Appendices/seisio_file_format:seisio-write-formats}}\label{\detokenize{src/Appendices/seisio_file_format:seisio-file-format}}\label{\detokenize{src/Appendices/seisio_file_format::doc}}
Files are written in little-endian byte order. Abbreviations used:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{21}|\X{10}{21}|\X{4}{21}|\X{4}{21}|}
\hline
\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
C
&\sphinxstyletheadfamily 
Fortran 77
\\
\hline
Char
&
Unicode character
&
wchar
&
CHARACTER*4
\\
\hline
Float32
&
32-bit float
&
float
&
REAL
\\
\hline
Float64
&
64-bit float
&
double
&
REAL*8
\\
\hline
Int8
&
signed 8-bit int
&
short
&
INTEGER
\\
\hline
Int16
&
signed 16-bit int
&
int
&
INTEGER*2
\\
\hline
Int32
&
signed 32-bit int
&
long
&
INTEGER*4
\\
\hline
Int64
&
signed 64-bit integer
&
long long
&
INTEGER*8
\\
\hline
UInt8
&
unsigned 8-bit int
&
unsigned short
&
CHARACTER
\\
\hline
UInt16
&
unsigned 16-bit int
&
unsigned
&\\
\hline
UInt32
&
unsigned 32-bit int
&
unsigned long
&\\
\hline
UInt64
&
unsigned 64-bit int
&
unsigned long long
&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{DUlineblock}{0em}
\item[] Special instructions:
\item[] 
\item[] Parentheses, “()”, denote a custom object Type.
\item[] “\{ (condition)” denotes the start of a loop; (condition) is the control flow.
\item[] “\}” denotes the end of a loop.
\end{DUlineblock}

Note that String in Julia has no exact C equivalence. SeisIO writes each String
in two parts: an Int64 (String length in bytes) followed by the String contents
(as bytes, equivalent to UInt8). Unlike C/Fortran, there are no issues with
strings that contain the null character (0x00 or \sphinxcode{\sphinxupquote{'\textbackslash{}x0'}}).


\subsection{SeisIO File}
\label{\detokenize{src/Appendices/seisio_file_format:seisio-file}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{4}{52}|\X{32}{52}|\X{8}{52}|\X{8}{52}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
T
&\sphinxstyletheadfamily 
N
\\
\hline&
“SEISIO”
&
UInt8
&
6
\\
\hline
\sphinxcode{\sphinxupquote{V}}
&
SeisIO file format version
&
Float32
&
1
\\
\hline
\sphinxcode{\sphinxupquote{J}}
&
\# of SeisIO objects in file
&
UInt32
&
1
\\
\hline
\sphinxcode{\sphinxupquote{C}}
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:object-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO object codes}}}} for each object
&
UInt32
&
J
\\
\hline
\sphinxcode{\sphinxupquote{B}}
&
Byte indices for each object
&
UInt64
&
J
\\
\hline
\{
&&&
for i = 1:J
\\
\hline&
(Objects)
&
variable
&
J
\\
\hline
\}
&&&\\
\hline
\sphinxcode{\sphinxupquote{ID}}
&
ID hashes
&
UInt64
&
variable
\\
\hline
\sphinxcode{\sphinxupquote{TS}}
&
Start times
&
Int64
&
variable
\\
\hline
\sphinxcode{\sphinxupquote{TE}}
&
End times
&
Int64
&
variable
\\
\hline
\sphinxcode{\sphinxupquote{P}}
&
Parent object index in C and B
&
variable
&\\
\hline
\sphinxcode{\sphinxupquote{bID}}
&
Byte offset of \sphinxcode{\sphinxupquote{ID}} array
&
Int64
&
1
\\
\hline
\sphinxcode{\sphinxupquote{bTS}}
&
Byte offset of \sphinxcode{\sphinxupquote{TS}} array
&
Int64
&
1
\\
\hline
\sphinxcode{\sphinxupquote{bTE}}
&
Byte offset of \sphinxcode{\sphinxupquote{TE}} array
&
Int64
&
1
\\
\hline
\sphinxcode{\sphinxupquote{bP}}
&
Byte offset of \sphinxcode{\sphinxupquote{P}} array
&
Int64
&
1
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

ID, TS, and TE are the ID, data start time, and data end time of each channel
in each object. P is the index of the parent object in C and B. TS and TE are
measured from Unix epoch time (1970-01-01T00:00:00Z) in integer microseconds.

Intent: when seeking data from channel \sphinxcode{\sphinxupquote{i}} between times \sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}},
if \sphinxcode{\sphinxupquote{hash(i)}} matches \sphinxcode{\sphinxupquote{ID{[}j{]}}} and the time windows overlap, retrieve index
\sphinxcode{\sphinxupquote{k = P{[}j{]}}} from NP, seek to byte offset \sphinxcode{\sphinxupquote{B{[}k{]}}}, and read an object of
type \sphinxcode{\sphinxupquote{C{[}k{]}}} from file.

If an archive contains no data objects, ID, TS, TE, and P are empty;
equivalently, \sphinxcode{\sphinxupquote{bID == bTS}}.


\section{Simple Object Types}
\label{\detokenize{src/Appendices/seisio_file_format:simple-object-types}}
Fields of these objects are written in one of three ways: as “plain data” types,
such as UInt8 or Float64; as arrays; or as strings.

In a simple object, each array is stored as follows:
1. Int64 number of dimensions (e.g. 2)
2. Int64 array of dimensions themselves (e.g. 2, 2)
3. Array values (e.g. 0.08250153, 0.023121119, 0.6299772, 0.79595184)


\subsection{EQLoc}
\label{\detokenize{src/Appendices/seisio_file_format:eqloc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{11}|\X{1}{11}|\X{1}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
lat
&
Float64
&
1
&
latitude
\\
\hline
lon
&
Float64
&
1
&
longitude
\\
\hline
dep
&
Float64
&
1
&
depth
\\
\hline
dx
&
Float64
&
1
&
x-error
\\
\hline
dy
&
Float64
&
1
&
y-error
\\
\hline
dz
&
Float64
&
1
&
z-error
\\
\hline
dt
&
Float64
&
1
&
t-error (error in origin time)
\\
\hline
se
&
Float64
&
1
&
standard error
\\
\hline
rms
&
Float64
&
1
&
rms pick error
\\
\hline
gap
&
Float64
&
1
&
azimuthal gap
\\
\hline
dmin
&
Float64
&
1
&
minimum source-receiver distance in location
\\
\hline
dmax
&
Float64
&
1
&
maximum source-receiver distance in location
\\
\hline
nst
&
Int64
&
1
&
number of stations used to locate earthquake
\\
\hline
flags
&
UInt8
&
1
&
one-bit flags for special location properties
\\
\hline
Ld
&
Int64
&
1
&
length of “datum” string in bytes
\\
\hline
datum
&
UInt8
&
Ld
&
Datum string
\\
\hline
Lt
&
Int64
&
1
&
length of “typ” (event type) string in bytes
\\
\hline
typ
&
UInt8
&
Lt
&
earthquake type string
\\
\hline
Li
&
Int64
&
1
&
length of “sig” (error significance) string in bytes
\\
\hline
sig
&
UInt8
&
Li
&
earthquake location error significance string
\\
\hline
Lr
&
Int64
&
1
&
length of “src” (data source) string in bytes
\\
\hline
src
&
UInt8
&
Lr
&
data source string
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{DUlineblock}{0em}
\item[] flag meanings: (0x01 = true, 0x00 = false)
\item[] 1. x fixed?
\item[] 2. y fixed?
\item[] 3. z fixed?
\item[] 4. t fixed?
\item[] In Julia, get the value of flag{[}n{]} with \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}(\textless{}\textless{}(flags, n-1), 7)}}.
\end{DUlineblock}


\subsection{EQMag}
\label{\detokenize{src/Appendices/seisio_file_format:eqmag}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
val
&
Float32
&
1
&
magnitude value
\\
\hline
gap
&
Float64
&
1
&
largest azimuthal gap between stations in magnitude
\\
\hline
nst
&
Int64
&
1
&
number of stations used in magnitude computation
\\
\hline
Lsc
&
Int64
&
1
&
length of magnitude scale string
\\
\hline
msc
&
UInt8
&
Lsc
&
magnitude scale string
\\
\hline
Lr
&
Int64
&
1
&
length of data source string
\\
\hline
src
&
UInt8
&
Lr
&
data source string
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{SeisPha}
\label{\detokenize{src/Appendices/seisio_file_format:seispha}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
F
&
Float64
&
8
&
amplitude, distance, incidence angle, residual,
\\
\hline&&&
ray parameter, takeoff angle, travel time, uncertainty
\\
\hline
C
&
Char
&
2
&
polarity, quality
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{SourceTime}
\label{\detokenize{src/Appendices/seisio_file_format:sourcetime}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ld
&
Int64
&
1
&
size of descriptive string in bytes
\\
\hline
desc
&
UInt8
&
1
&
descriptive string
\\
\hline
F
&
Float64
&
3
&
duration, rise time, decay time
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{StringVec}
\label{\detokenize{src/Appendices/seisio_file_format:stringvec}}
A vector of variable-length strings; its exact Type in Julia is Array\{String,1\}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{StringVec}\label{\detokenize{src/Appendices/seisio_file_format:id17}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{1}{11}|\X{1}{11}|\X{1}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
ee
&
UInt8
&
1
&
is this string vector empty? %
\begin{footnote}[1]\sphinxAtStartFootnote
If \sphinxcode{\sphinxupquote{ee == 0x00}}, then no values are stored for L, nb, or str.
%
\end{footnote}
\\
\hline
L
&
Int64
&
1
&
number of strings to read
\\
\hline
\{
&&&
i = 1:L
\\
\hline
nb
&
Int64
&
1
&
length of string in bytes
\\
\hline
str
&
UInt8
&
nb
&
string
\\
\hline
\}
&&&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Location Types}
\label{\detokenize{src/Appendices/seisio_file_format:location-types}}

\subsection{GenLoc}
\label{\detokenize{src/Appendices/seisio_file_format:genloc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{11}|\X{1}{11}|\X{1}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ld
&
Int64
&
1
&
length of datum string in bytes
\\
\hline
datum
&
UInt8
&
Ld
&
datum string
\\
\hline
Ll
&
Int64
&
1
&
length of location vector in bytes
\\
\hline
loc
&
Float64
&
Ll
&
location vector
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{GeoLoc}
\label{\detokenize{src/Appendices/seisio_file_format:geoloc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{11}|\X{1}{11}|\X{1}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ld
&
Int64
&
1
&
length of datum string in bytes
\\
\hline
datum
&
UInt8
&
Ld
&
datum string
\\
\hline
F
&
Float64
&
6
&
latitude, longitude, elevation,
\\
\hline&&&
depth, azimuth, incidence
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{UTMLoc}
\label{\detokenize{src/Appendices/seisio_file_format:utmloc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{11}|\X{1}{11}|\X{1}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ld
&
Int64
&
1
&
length of datum string in bytes
\\
\hline
datum
&
UInt8
&
N
&
datum string
\\
\hline
zone
&
Int8
&
1
&
UTM zone number
\\
\hline
hemi
&
Char
&
1
&
hemisphere
\\
\hline
E
&
UInt64
&
1
&
Easting
\\
\hline
N
&
UInt64
&
1
&
Northing
\\
\hline
F
&
Float64
&
4
&
elevation, depth, azimuth, incidence
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{XYLoc}
\label{\detokenize{src/Appendices/seisio_file_format:xyloc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{11}|\X{1}{11}|\X{1}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ld
&
Int64
&
1
&
Length of datum string in bytes
\\
\hline
datum
&
UInt8
&
Ld
&
datum string
\\
\hline
F
&
Float64
&
8
&
x, y, z, azimuth, incidence, origin x, origin y, origin z
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Response Types}
\label{\detokenize{src/Appendices/seisio_file_format:response-types}}

\subsection{GenResp}
\label{\detokenize{src/Appendices/seisio_file_format:genresp}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{13}|\X{3}{13}|\X{1}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ld
&
Int64
&
1
&
length of descriptive string in bytes
\\
\hline
desc
&
UInt8
&
Ld
&
descriptive string
\\
\hline
nr
&
Int64
&
1
&
Number of rows in complex response matrix
\\
\hline
nc
&
Int64
&
1
&
Number of columns in complex response matrix
\\
\hline
resp
&
Complex\{Float64,2\}
&
nr*nc
&
complex response matrix
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{PZResp}
\label{\detokenize{src/Appendices/seisio_file_format:pzresp}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{13}|\X{3}{13}|\X{1}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
c
&
Float32
&
1
&
damping constant
\\
\hline
np
&
Int64
&
1
&
number of complex poles
\\
\hline
p
&
Complex\{Float32,1\}
&
np
&
complex poles vector
\\
\hline
nz
&
Int64
&
1
&
number of complex zeros
\\
\hline
z
&
Complex\{Float32,1\}
&
nz
&
complex zeros vector
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

PZResp64 is identical to PZResp with Float64 values for c, p, z, rather than Float32.


\section{The Misc Dictionary}
\label{\detokenize{src/Appendices/seisio_file_format:the-misc-dictionary}}
Most compound objects below contain a dictionary (Dict\{String,Any\}) for
non-essential information in a field named \sphinxcode{\sphinxupquote{:misc}}. The tables below describe
how this field is written to disk.


\subsection{Misc}
\label{\detokenize{src/Appendices/seisio_file_format:misc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
N
&
Int64
&
1
&
number of items in dictionary %
\begin{footnote}[2]\sphinxAtStartFootnote
If \sphinxcode{\sphinxupquote{N == 0}}, then N is the only value present.
%
\end{footnote}
\\
\hline
K
&
(StringVec)
&
1
&
dictionary keys
\\
\hline
\{
&&&
for i = 1:N
\\
\hline
c
&
UInt8
&
1
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:type-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{Type code}}}} of object i
\\
\hline
o
&
variable
&
1
&
object i
\\
\hline
\}
&&&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Dictionary Contents}
\label{\detokenize{src/Appendices/seisio_file_format:dictionary-contents}}
These subtables describe how to read the possible data types in a Misc dictionary.


\subsection{String Array (c == 0x81)}
\label{\detokenize{src/Appendices/seisio_file_format:string-array-c-0x81}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
A
&
(StringVec)
&
1
&
string vector
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Other Array (c == 0x80 or c \textgreater{} 0x81)}
\label{\detokenize{src/Appendices/seisio_file_format:other-array-c-0x80-or-c-0x81}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{1}{12}|\X{2}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
nd
&
Int64
&
1
&
number of dimensions in array
\\
\hline
dims
&
Int64
&
nd
&
array dimensions
\\
\hline
arr
&
varies
&
prod(nd)
&
array
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{String (c == 0x01)}
\label{\detokenize{src/Appendices/seisio_file_format:string-c-0x01}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{11}|\X{1}{11}|\X{1}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
L
&
Int64
&
1
&
size of string in bytes
\\
\hline
str
&
UInt8
&
1
&
string
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Bits Type (c == 0x00 or 0x01 \textless{} c \textless{} 0x7f)}
\label{\detokenize{src/Appendices/seisio_file_format:bits-type-c-0x00-or-0x01-c-0x7f}}
Read a single value whose Type corresponds to the UInt8 {\hyperref[\detokenize{src/Appendices/seisio_file_format:type-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{Type code}}}}.


\section{Compound Object Types}
\label{\detokenize{src/Appendices/seisio_file_format:compound-object-types}}
Each of these objects contains at least one of the above simple object types.


\subsection{PhaseCat}
\label{\detokenize{src/Appendices/seisio_file_format:phasecat}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
N
&
Int64
&
1
&
number of SeisPha objects to read  %
\begin{footnote}[3]\sphinxAtStartFootnote
If \sphinxcode{\sphinxupquote{N == 0}}, then N is the only value present.
%
\end{footnote}
\\
\hline
K
&
(StringVec)
&
1
&
dictionary keys
\\
\hline
pha
&
(SeisPha)
&
N
&
seismic phases
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{EventChannel}
\label{\detokenize{src/Appendices/seisio_file_format:eventchannel}}
A single channel of data related to a seismic event


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ni
&
Int64
&
1
&
size of id string in bytes
\\
\hline
id
&
UInt8
&
Ni
&
id string
\\
\hline
Nn
&
Int64
&
1
&
size of name string in bytes
\\
\hline
name
&
UInt8
&
Nn
&
name string
\\
\hline
Lt
&
UInt8
&
1
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:loc-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{location Type code}}}}
\\
\hline
loc
&
(Loc Type)
&
1
&
instrument position
\\
\hline
fs
&
Float64
&
1
&
sampling frequency in Hz
\\
\hline
gain
&
Float64
&
1
&
scalar gain
\\
\hline
Rt
&
UInt8
&
1
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:resp-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{response Type code}}}}
\\
\hline
resp
&
(Resp Type)
&
1
&
instrument response
\\
\hline
Nu
&
Int64
&
1
&
size of units string in bytes
\\
\hline
units
&
UInt8
&
Nu
&
units string
\\
\hline
az
&
Float64
&
1
&
azimuth
\\
\hline
baz
&
Float64
&
1
&
backazimuth
\\
\hline
dist
&
Float64
&
1
&
source-receiver distance
\\
\hline
pha
&
(PhaseCat)
&
1
&
phase catalog
\\
\hline
Nr
&
Int64
&
1
&
size of data source string in bytes
\\
\hline
src
&
UInt8
&
Nr
&
data source string
\\
\hline
misc
&
(Misc)
&
1
&
dictionary for non-essential information
\\
\hline
notes
&
(StringVec)
&
1
&
notes and automated logging
\\
\hline
Nt
&
Int64
&
1
&
length of time gaps matrix
\\
\hline
T
&
Int64
&
2Nt
&
time gaps matrix
\\
\hline
Xc
&
UInt8
&
1
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:type-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{Type code}}}} of data vector
\\
\hline
Nx
&
Int64
&
1
&
number of samples in data vector
\\
\hline
X
&
variable
&
NX
&
data vector
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{SeisChannel}
\label{\detokenize{src/Appendices/seisio_file_format:seischannel}}
A single channel of univariate geophysical data
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Ni
&
Int64
&
1
&
size of id string in bytes
\\
\hline
id
&
UInt8
&
Ni
&
id string
\\
\hline
Nn
&
Int64
&
1
&
size of name string in bytes
\\
\hline
name
&
UInt8
&
Nn
&
name string
\\
\hline
Lt
&
UInt8
&
1
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:loc-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{location Type code}}}}
\\
\hline
loc
&
(Loc Type)
&
1
&
instrument position
\\
\hline
fs
&
Float64
&
1
&
sampling frequency in Hz
\\
\hline
gain
&
Float64
&
1
&
scalar gain
\\
\hline
Rt
&
UInt8
&
1
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:resp-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{response Type code}}}}
\\
\hline
resp
&
(Resp Type)
&
1
&
instrument response
\\
\hline
Nu
&
Int64
&
1
&
size of units string in bytes
\\
\hline
units
&
UInt8
&
Nu
&
units string
\\
\hline
Nr
&
Int64
&
1
&
size of data source string in bytes
\\
\hline
src
&
UInt8
&
Nr
&
data source string
\\
\hline
misc
&
(Misc)
&
1
&
dictionary for non-essential information
\\
\hline
notes
&
(StringVec)
&
1
&
notes and automated logging
\\
\hline
Nt
&
Int64
&
1
&
length of time gaps matrix
\\
\hline
T
&
Int64
&
2Nt
&
time gaps matrix
\\
\hline
Xc
&
UInt8
&
1
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:type-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{Type code}}}} of data vector
\\
\hline
Nx
&
Int64
&
1
&
number of samples in data vector
\\
\hline
X
&
variable
&
NX
&
data vector
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{EventTraceData}
\label{\detokenize{src/Appendices/seisio_file_format:eventtracedata}}
A multichannel record of time-series data related to a seismic event.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
N
&
Int64
&
1
&
number of data channels
\\
\hline
Lc
&
UInt8
&
N
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:loc-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{location Type codes}}}} for each data channel
\\
\hline
Rc
&
UInt8
&
N
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:resp-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{response Type codes}}}} for each data channel
\\
\hline
Xc
&
UInt8
&
N
&
data {\hyperref[\detokenize{src/Appendices/seisio_file_format:type-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{Type codes}}}} for each data channel
\\
\hline
cmp
&
UInt8
&
1
&
are data compressed? (0x01 = yes)
\\
\hline
Nt
&
Int64
&
N
&
number of rows in time gaps matrix for each channel
\\
\hline
Nx
&
Int64
&
N
&
length of data vector for each channel %
\begin{footnote}[4]\sphinxAtStartFootnote
If cmp == 0x01, each value in Nx is the number of bytes of compressed data to read; otherwise, this is the number of samples in each channel.
%
\end{footnote}
\\
\hline
id
&
(StringVec)
&
1
&
channel ids
\\
\hline
name
&
(StringVec)
&
1
&
channel names
\\
\hline
loc
&
(Loc Type)
&
N
&
instrument positions
\\
\hline
fs
&
Float64
&
N
&
sampling frequencies of each channel in Hz
\\
\hline
gain
&
Float64
&
N
&
scalar gains of each channel
\\
\hline
resp
&
(Resp Type)
&
N
&
instrument responses
\\
\hline
units
&
(StringVec)
&
1
&
units of each channel’s data
\\
\hline
az
&
Float64
&
N
&
event azimuth
\\
\hline
baz
&
Float64
&
N
&
backazimuths to event
\\
\hline
dist
&
Float64
&
N
&
source-receiver distances
\\
\hline
pha
&
(PhaseCat)
&
N
&
phase catalogs for each channel
\\
\hline
src
&
(StringVec)
&
1
&
data source strings for each channel
\\
\hline
misc
&
(Misc)
&
N
&
dictionaries of non-essential information for each channel
\\
\hline
notes
&
(StringVec)
&
N
&
notes and automated logging for each channel
\\
\hline
\{
&&&
for i = 1:N
\\
\hline
T
&
Int64
&
2Nt{[}i{]}
&
Matrix of time gaps for channel i
\\
\hline
\}
&&&\\
\hline
\{
&&&
for i = 1:N
\\
\hline
X
&
Xc{[}i{]}
&
Nx{[}i{]}
&
Data vector i %
\begin{footnote}[5]\sphinxAtStartFootnote
If cmp == 0x01, read Nx{[}i{]} samples of type UInt8 and pass through lz4 decompression to generate data vector i; else read Nx{[}i{]} samples of the type corresponding to code Xc{[}i{]}.
%
\end{footnote}
\\
\hline
\}
&&&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{SeisData}
\label{\detokenize{src/Appendices/seisio_file_format:seisdata}}
A record containing multiple channels of univariate geophysical data.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
N
&
Int64
&
1
&
number of data channels
\\
\hline
Lc
&
UInt8
&
N
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:loc-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{location Type codes}}}} for each data channel
\\
\hline
Rc
&
UInt8
&
N
&
{\hyperref[\detokenize{src/Appendices/seisio_file_format:resp-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{response Type codes}}}} for each data channel
\\
\hline
Xc
&
UInt8
&
N
&
data {\hyperref[\detokenize{src/Appendices/seisio_file_format:type-codes}]{\sphinxcrossref{\DUrole{std,std-ref}{Type codes}}}} for each data channel
\\
\hline
cmp
&
UInt8
&
1
&
are data compressed? (0x01 = yes)
\\
\hline
Nt
&
Int64
&
N
&
number of rows in time gaps matrix for each channel
\\
\hline
Nx
&
Int64
&
N
&
length of data vector for each channel %
\begin{footnote}[6]\sphinxAtStartFootnote
If cmp == 0x01, each value in Nx is the number of bytes of compressed data to read; otherwise, this is the number of samples in each channel.
%
\end{footnote}
\\
\hline
id
&
(StringVec)
&
1
&
channel ids
\\
\hline
name
&
(StringVec)
&
1
&
channel names
\\
\hline
loc
&
(Loc Type)
&
N
&
instrument positions
\\
\hline
fs
&
Float64
&
N
&
sampling frequencies of each channel in Hz
\\
\hline
gain
&
Float64
&
N
&
scalar gains of each channel
\\
\hline
resp
&
(Resp Type)
&
N
&
instrument responses
\\
\hline
units
&
(StringVec)
&
1
&
units of each channel’s data
\\
\hline
src
&
(StringVec)
&
1
&
data source strings for each channel
\\
\hline
misc
&
(Misc)
&
N
&
dictionaries of non-essential information for each channel
\\
\hline
notes
&
(StringVec)
&
N
&
notes and automated logging for each channel
\\
\hline
\{
&&&
for i = 1:N
\\
\hline
T
&
Int64
&
2Nt{[}i{]}
&
Matrix of time gaps for channel i
\\
\hline
\}
&&&\\
\hline
\{
&&&
for i = 1:N
\\
\hline
X
&
Xc{[}i{]}
&
Nx{[}i{]}
&
Data vector i %
\begin{footnote}[7]\sphinxAtStartFootnote
If cmp == 0x01, read Nx{[}i{]} samples of type UInt8 and pass through lz4 decompression to generate data vector i; else read Nx{[}i{]} samples of the type corresponding to code Xc{[}i{]}.
%
\end{footnote}
\\
\hline
\}
&&&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{SeisHdr}
\label{\detokenize{src/Appendices/seisio_file_format:seishdr}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{12}|\X{2}{12}|\X{1}{12}|\X{8}{12}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Li
&
Int64
&
1
&
length of event ID string
\\
\hline
id
&
UInt8
&
Li
&
event ID string
\\
\hline
iv
&
UInt8
&
1
&
intensity value
\\
\hline
Ls
&
Int64
&
1
&
length of intensity scale string
\\
\hline
isc
&
UInt8
&
Ls
&
intensity scale string
\\
\hline
loc
&
(EQLoc)
&
1
&
earthquake location
\\
\hline
mag
&
(EQMag)
&
1
&
earthquake magnitude
\\
\hline
misc
&
(Misc)
&
1
&
dictionary containing non-essential information
\\
\hline
notes
&
(StringVec)
&
1
&
notes and automated logging
\\
\hline
ot
&
Int64
&
1
&
origin time %
\begin{footnote}[8]\sphinxAtStartFootnote
Measured from Unix epoch time (1970-01-01T00:00:00Z) in integer microseconds
%
\end{footnote}
\\
\hline
Lr
&
Int64
&
1
&
length of data source string
\\
\hline
src
&
UInt8
&
Lr
&
data source string
\\
\hline
Lt
&
Int64
&
1
&
length of event type string
\\
\hline
typ
&
UInt8
&
Lt
&
event type string
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{SeisSrc}
\label{\detokenize{src/Appendices/seisio_file_format:seissrc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{13}|\X{2}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
Li
&
Int64
&
1
&
length of source id string
\\
\hline
id
&
UInt8
&
Li
&
id string
\\
\hline
Le
&
Int64
&
1
&
length of event id string
\\
\hline
eid
&
UInt8
&
Le
&
event id string
\\
\hline
m0
&
Float64
&
1
&
scalar moment
\\
\hline
Lm
&
Int64
&
1
&
length of moment tensor vector
\\
\hline
mt
&
Float64
&
Lm
&
moment tensor vector
\\
\hline
Ld
&
Int64
&
1
&
length of moment tensor misfit vector
\\
\hline
dm
&
Float64
&
Ld
&
moment tensor misfit vector
\\
\hline
np
&
Int64
&
1
&
number of polarities
\\
\hline
gap
&
Float64
&
1
&
max. azimuthal gap
\\
\hline
pad
&
Int64
&
2
&
dimensions of principal axes matrix
\\
\hline
pax
&
Float64
&
pad{[}1{]}*pad{[}2{]}
&
principal axes matrix
\\
\hline
pld
&
Int64
&
2
&
dimensions of nodal planes matrix
\\
\hline
planes
&
Float64
&
pld{[}1{]}*pld{[}2{]}
&
nodal planes matrix
\\
\hline
Lr
&
Int64
&
1
&
length of data source string
\\
\hline
src
&
UInt8
&
1
&
data source string
\\
\hline
st
&
(SourceTime)
&
1
&
source-time description
\\
\hline
misc
&
(Misc)
&
1
&
Dictionary containing non-essential information
\\
\hline
notes
&
(StringVec)
&
1
&
Notes and automated logging
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{SeisEvent}
\label{\detokenize{src/Appendices/seisio_file_format:seisevent}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{13}|\X{3}{13}|\X{1}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
hdr
&
(SeisHdr)
&
1
&
event header
\\
\hline
source
&
(SeisSrc)
&
1
&
event source process
\\
\hline
data
&
(EventTraceData)
&
1
&
event trace data
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Data Type Codes}
\label{\detokenize{src/Appendices/seisio_file_format:data-type-codes}}
Each Type code is written to disk as a UInt8, with the important exception of
SeisIO custom object Type codes (which use UInt32).


\subsection{Loc Type Codes}
\label{\detokenize{src/Appendices/seisio_file_format:loc-type-codes}}\label{\detokenize{src/Appendices/seisio_file_format:loc-codes}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{3}|\X{2}{3}|}
\hline
\sphinxstyletheadfamily 
UInt8
&\sphinxstyletheadfamily 
Type
\\
\hline
0x00
&
GenLoc
\\
\hline
0x01
&
GeoLoc
\\
\hline
0x02
&
UTMLoc
\\
\hline
0x03
&
XYLoc
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Resp Type Codes}
\label{\detokenize{src/Appendices/seisio_file_format:resp-type-codes}}\label{\detokenize{src/Appendices/seisio_file_format:resp-codes}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{3}|\X{2}{3}|}
\hline
\sphinxstyletheadfamily 
UInt8
&\sphinxstyletheadfamily 
Type
\\
\hline
0x00
&
GenResp
\\
\hline
0x01
&
PZResp
\\
\hline
0x02
&
PZResp64
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Other Type Codes}
\label{\detokenize{src/Appendices/seisio_file_format:other-type-codes}}\label{\detokenize{src/Appendices/seisio_file_format:type-codes}}
Only the Types below are faithfully preserved in write/read of a :misc field
dictionary; other Types are not written to file and can cause \sphinxcode{\sphinxupquote{wseis}} to
throw errors.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{9}|\X{1}{9}|\X{4}{9}|\X{1}{9}|}
\hline
\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
UInt8
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
UInt8
\\
\hline
Char
&
0x00
&
Array\{Char,N\}
&
0x80
\\
\hline
String
&
0x01
&
Array\{String,N\}
&
0x81
\\
\hline
UInt8
&
0x10
&
Array\{UInt8,N\}
&
0x90
\\
\hline
UInt16
&
0x11
&
Array\{UInt16,N\}
&
0x91
\\
\hline
UInt32
&
0x12
&
Array\{UInt32,N\}
&
0x92
\\
\hline
UInt64
&
0x13
&
Array\{UInt64,N\}
&
0x93
\\
\hline
UInt128
&
0x14
&
Array\{UInt128,N\}
&
0x94
\\
\hline
Int8
&
0x20
&
Array\{Int8,N\}
&
0xa0
\\
\hline
Int16
&
0x21
&
Array\{Int16,N\}
&
0xa1
\\
\hline
Int32
&
0x22
&
Array\{Int32,N\}
&
0xa2
\\
\hline
Int64
&
0x23
&
Array\{Int64,N\}
&
0xa3
\\
\hline
Int128
&
0x24
&
Array\{Int128,N\}
&
0xa4
\\
\hline
Float16
&
0x30
&
Array\{Float16,N\}
&
0xb0
\\
\hline
Float32
&
0x31
&
Array\{Float32,N\}
&
0xb1
\\
\hline
Float64
&
0x32
&
Array\{Float64,N\}
&
0xb2
\\
\hline
Complex\{UInt8\}
&
0x50
&
Array\{Complex\{UInt8\},N\}
&
0xd0
\\
\hline
Complex\{UInt16\}
&
0x51
&
Array\{Complex\{UInt16\},N\}
&
0xd1
\\
\hline
Complex\{UInt32\}
&
0x52
&
Array\{Complex\{UInt32\},N\}
&
0xd2
\\
\hline
Complex\{UInt64\}
&
0x53
&
Array\{Complex\{UInt64\},N\}
&
0xd3
\\
\hline
Complex\{UInt128\}
&
0x54
&
Array\{Complex\{UInt128\},N\}
&
0xd4
\\
\hline
Complex\{Int8\}
&
0x60
&
Array\{Complex\{Int8\},N\}
&
0xe0
\\
\hline
Complex\{Int16\}
&
0x61
&
Array\{Complex\{Int16\},N\}
&
0xe1
\\
\hline
Complex\{Int32\}
&
0x62
&
Array\{Complex\{Int32\},N\}
&
0xe2
\\
\hline
Complex\{Int64\}
&
0x63
&
Array\{Complex\{Int64\},N\}
&
0xe3
\\
\hline
Complex\{Int128\}
&
0x64
&
Array\{Complex\{Int128\},N\}
&
0xe4
\\
\hline
Complex\{Float16\}
&
0x70
&
Array\{Complex\{Float16\},N\}
&
0xf0
\\
\hline
Complex\{Float32\}
&
0x71
&
Array\{Complex\{Float32\},N\}
&
0xf1
\\
\hline
Complex\{Float64\}
&
0x72
&
Array\{Complex\{Float64\},N\}
&
0xf2
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{SeisIO Object Type codes}
\label{\detokenize{src/Appendices/seisio_file_format:seisio-object-type-codes}}\label{\detokenize{src/Appendices/seisio_file_format:object-codes}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{2}{5}|\X{3}{5}|}
\hline
\sphinxstyletheadfamily 
UInt32 Code
&\sphinxstyletheadfamily 
Object Type
\\
\hline
0x20474330
&
EventChannel
\\
\hline
0x20474331
&
SeisChannel
\\
\hline
0x20474430
&
EventTraceData
\\
\hline
0x20474431
&
SeisData
\\
\hline
0x20495030
&
GenLoc
\\
\hline
0x20495031
&
GeoLoc
\\
\hline
0x20495032
&
UTMLoc
\\
\hline
0x20495033
&
XYLoc
\\
\hline
0x20495230
&
GenResp
\\
\hline
0x20495231
&
PZResp64
\\
\hline
0x20495232
&
PZResp
\\
\hline
0x20504330
&
PhaseCat
\\
\hline
0x20534530
&
SeisEvent
\\
\hline
0x20534830
&
SeisHdr
\\
\hline
0x20535030
&
SeisPha
\\
\hline
0x20535330
&
SeisSrc
\\
\hline
0x20535430
&
SourceTime
\\
\hline
0x45514c30
&
EQLoc
\\
\hline
0x45514d30
&
EQMag
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Data Requests Syntax}
\label{\detokenize{src/Appendices/web_syntax:data-requests-syntax}}\label{\detokenize{src/Appendices/web_syntax::doc}}

\subsection{Channel ID Syntax}
\label{\detokenize{src/Appendices/web_syntax:channel-id-syntax}}\label{\detokenize{src/Appendices/web_syntax:cid}}
\sphinxcode{\sphinxupquote{NN.SSSSS.LL.CC}} (net.sta.loc.cha, separated by periods) is the expected syntax for all web functions. The maximum field width in characters corresponds to the length of each field (e.g. 2 for network). Fields can’t contain whitespace.

\sphinxcode{\sphinxupquote{NN.SSSSS.LL.CC.T}} (net.sta.loc.cha.tflag) is allowed in SeedLink. \sphinxcode{\sphinxupquote{T}} is a single-character data type flag and must be one of \sphinxcode{\sphinxupquote{DECOTL}}: Data, Event, Calibration, blOckette, Timing, or Logs. Calibration, timing, and logs are not in the scope of SeisIO and may crash SeedLink sessions.

The table below specifies valid types and expected syntax for channel lists.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{4}{20}|\X{8}{20}|\X{8}{20}|}
\hline
\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
&\sphinxstyletheadfamily 
Example
\\
\hline
String
&
Comma-delineated list of IDs
&
“PB.B004.01.BS1, PB.B002.01.BS1”
\\
\hline
Array\{String,1\}
&
String array, one ID string per entry
&
{[}“PB.B004.01.BS1”, “PB.B002.01.BS1”{]}
\\
\hline
Array\{String,2\}
&
String array, one set of IDs per row
&
{[}“PB” “B004” “01” “BS1”;
\\
\hline&&
“PB” “B002” “01” “BS1”{]}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

The expected component order is always network, station, location, channel; thus, “UW.TDH..EHZ” is OK, but “UW.TDH.EHZ” fails.
\index{chanspec() (built-in function)@\spxentry{chanspec()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/web_syntax:chanspec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{chanspec}}}{}{}
\end{fulllineitems}


Type \sphinxcode{\sphinxupquote{?chanspec}} in Julia to print the above info. to stdout.


\subsubsection{Wildcards and Blanks}
\label{\detokenize{src/Appendices/web_syntax:wildcards-and-blanks}}
Allowed wildcards are client-specific.
\begin{itemize}
\item {} 
The LOC field can be left blank in any client: \sphinxcode{\sphinxupquote{"UW.ELK..EHZ"}} and \sphinxcode{\sphinxupquote{{[}"UW" "ELK" "" "EHZ"{]}}} are all valid. Blank LOC fields are set to \sphinxcode{\sphinxupquote{-{-}}} in IRIS, \sphinxcode{\sphinxupquote{*}} in FDSN, and \sphinxcode{\sphinxupquote{??}} in SeedLink.

\item {} 
\sphinxcode{\sphinxupquote{?}} acts as a single-character wildcard in FDSN \& SeedLink. Thus, \sphinxcode{\sphinxupquote{CC.VALT..???}} is valid.

\item {} 
\sphinxcode{\sphinxupquote{*}} acts as a multi-character wildcard in FDSN. Thus, \sphinxcode{\sphinxupquote{CC.VALT..*}} and \sphinxcode{\sphinxupquote{CC.VALT..???}} behave identically in FDSN.

\item {} 
Partial specifiers are OK, but a network and station are always required: \sphinxcode{\sphinxupquote{"UW.EL?"}} is OK, \sphinxcode{\sphinxupquote{".ELK.."}} fails.

\end{itemize}


\subsubsection{Channel Configuration Files}
\label{\detokenize{src/Appendices/web_syntax:channel-configuration-files}}\label{\detokenize{src/Appendices/web_syntax:ccfg}}
One entry per line, ASCII text, format NN.SSSSS.LL.CCC.D. Due to client-specific wildcard rules, the most versatile configuration files are those that specify each channel most completely:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} This only works with SeedLink
GE.ISP..BH?.D
NL.HGN
MN.AQU..BH?
MN.AQU..HH?
UW.KMO
CC.VALT..BH?.D

\PYGZsh{} This works with FDSN and SeedLink, but not IRIS
GE.ISP..BH?
NL.HGN
MN.AQU..BH?
MN.AQU..HH?
UW.KMO
CC.VALT..BH?

\PYGZsh{} This works with all three:
GE.ISP..BHZ
GE.ISP..BHN
GE.ISP..BHE
MN.AQU..BHZ
MN.AQU..BHN
MN.AQU..BHE
MN.AQU..HHZ
MN.AQU..HHN
MN.AQU..HHE
UW.KMO..EHZ
CC.VALT..BHZ
CC.VALT..BHN
CC.VALT..BHE
\end{sphinxVerbatim}


\subsubsection{Server List}
\label{\detokenize{src/Appendices/web_syntax:server-list}}\label{\detokenize{src/Appendices/web_syntax:servers}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
String
&\sphinxstyletheadfamily 
Source
\\
\hline
BGR
&
\sphinxurl{http://eida.bgr.de}
\\
\hline
EMSC
&
\sphinxurl{http://www.seismicportal.eu}
\\
\hline
ETH
&
\sphinxurl{http://eida.ethz.ch}
\\
\hline
GEONET
&
\sphinxurl{http://service.geonet.org.nz}
\\
\hline
GFZ
&
\sphinxurl{http://geofon.gfz-potsdam.de}
\\
\hline
ICGC
&
\sphinxurl{http://ws.icgc.cat}
\\
\hline
INGV
&
\sphinxurl{http://webservices.ingv.it}
\\
\hline
IPGP
&
\sphinxurl{http://eida.ipgp.fr}
\\
\hline
IRIS
&
\sphinxurl{http://service.iris.edu}
\\
\hline
ISC
&
\sphinxurl{http://isc-mirror.iris.washington.edu}
\\
\hline
KOERI
&
\sphinxurl{http://eida.koeri.boun.edu.tr}
\\
\hline
LMU
&
\sphinxurl{http://erde.geophysik.uni-muenchen.de}
\\
\hline
NCEDC
&
\sphinxurl{http://service.ncedc.org}
\\
\hline
NIEP
&
\sphinxurl{http://eida-sc3.infp.ro}
\\
\hline
NOA
&
\sphinxurl{http://eida.gein.noa.gr}
\\
\hline
ORFEUS
&
\sphinxurl{http://www.orfeus-eu.org}
\\
\hline
RESIF
&
\sphinxurl{http://ws.resif.fr}
\\
\hline
SCEDC
&
\sphinxurl{http://service.scedc.caltech.edu}
\\
\hline
TEXNET
&
\sphinxurl{http://rtserve.beg.utexas.edu}
\\
\hline
USGS
&
\sphinxurl{http://earthquake.usgs.gov}
\\
\hline
USP
&
\sphinxurl{http://sismo.iag.usp.br}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{seis\_www() (built-in function)@\spxentry{seis\_www()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/web_syntax:seis_www}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{seis\_www}}}{}{}
\end{fulllineitems}


Type \sphinxcode{\sphinxupquote{?seis\_www}} in Julia to print the above info. to stdout.
\end{quote}


\subsection{Time Syntax}
\label{\detokenize{src/Appendices/web_syntax:time-syntax}}\label{\detokenize{src/Appendices/web_syntax:id1}}
Specify time inputs for web queries as a DateTime, Real, or String. The latter must take the form YYYY-MM-DDThh:mm:ss.nnn, where \sphinxcode{\sphinxupquote{T}} is the uppercase character \sphinxtitleref{T} and \sphinxcode{\sphinxupquote{nnn}} denotes milliseconds; incomplete time strings treat missing fields as 0.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{40}|\X{8}{40}|\X{24}{40}|}
\hline
\sphinxstyletheadfamily 
type(s)
&\sphinxstyletheadfamily 
type(t)
&\sphinxstyletheadfamily 
behavior
\\
\hline
DT
&
DT
&
Sort only
\\
\hline
R
&
DT
&
Add \sphinxcode{\sphinxupquote{s}} seconds to \sphinxcode{\sphinxupquote{t}}
\\
\hline
DT
&
R
&
Add \sphinxcode{\sphinxupquote{t}} seconds to \sphinxcode{\sphinxupquote{s}}
\\
\hline
S
&
R
&
Convert \sphinxcode{\sphinxupquote{s}} to DateTime, add \sphinxcode{\sphinxupquote{t}}
\\
\hline
R
&
S
&
Convert \sphinxcode{\sphinxupquote{t}} to DateTime, add \sphinxcode{\sphinxupquote{s}}
\\
\hline
R
&
R
&
Add \sphinxcode{\sphinxupquote{s, t}} seconds to \sphinxcode{\sphinxupquote{now()}}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

(above, R = Real, DT = DateTime, S = String, I = Integer)


\section{SeisIO Standard Keywords}
\label{\detokenize{src/Appendices/keywords:seisio-standard-keywords}}\label{\detokenize{src/Appendices/keywords:dkw}}\label{\detokenize{src/Appendices/keywords::doc}}
SeisIO.KW is a memory-resident structure of default values for common keywords
used by package functions. KW has one substructure, SL, with keywords specific
to SeedLink. These defaults can be modified, e.g., SeisIO.KW.nev=2 changes the
default for nev to 2.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
KW
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
T \sphinxfootnotemark[1]
&\sphinxstyletheadfamily 
Meaning
\\
\hline%
\begin{footnotetext}[1]\sphinxAtStartFootnote
Types: A = Array, B = Boolean, C = Char, DT = DateTime, F = Float, I = Integer, R = Real, S = String, U8 = Unsigned 8-bit integer
%
\end{footnotetext}\ignorespaces 
evw
&
{[}600.0, 600.0{]}
&
A\{F,1\}
&
time search window {[}o-evw{[}1{]}, o+evw{[}2{]}{]}
\\
\hline
fmt
&
“miniseed”
&
S
&
request data format
\\
\hline
mag
&
{[}6.0, 9.9{]}
&
A\{F,1\}
&
magnitude range for queries
\\
\hline
nd
&
1
&
I
&
number of days per subrequest
\\
\hline
nev
&
1
&
I
&
number of events returned per query
\\
\hline
nx\_add
&
360000
&
I
&
length increase of undersized data array
\\
\hline
nx\_new
&
8640000
&
I
&
number of samples for a new channel
\\
\hline
opts
&
“”
&
S
&
user-specified options %
\begin{footnote}[2]\sphinxAtStartFootnote
String is passed as-is, e.g. “szsrecs=true\&repo=realtime” for FDSN. String should not begin with an ampersand.
%
\end{footnote}
\\
\hline
pha
&
“P”
&
S
&
seismic phase arrival times to retrieve
\\
\hline
rad
&
{[}{]}
&
A\{F,1\}
&
radial search region %
\begin{footnote}[3]\sphinxAtStartFootnote
Specify region \sphinxstylestrong{{[}center\_lat, center\_lon, min\_radius, max\_radius, dep\_min, dep\_max{]}}, with lat, lon, and radius in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches.
%
\end{footnote}
\\
\hline
reg
&
{[}{]}
&
A\{F,1\}
&
rectangular search region %
\begin{footnote}[4]\sphinxAtStartFootnote
Specify region \sphinxstylestrong{{[}lat\_min, lat\_max, lon\_min, lon\_max, dep\_min, dep\_max{]}}, with lat, lon in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches.
%
\end{footnote}
\\
\hline
si
&
true
&
B
&
autofill station info on data req? %
\begin{footnote}[5]\sphinxAtStartFootnote
Not used with IRISWS.
%
\end{footnote}
\\
\hline
to
&
30
&
I
&
read timeout for web requests (s)
\\
\hline
v
&
0
&
I
&
verbosity
\\
\hline
w
&
false
&
B
&
write requests to disc? %
\begin{footnote}[6]\sphinxAtStartFootnote
\sphinxstylestrong{-v=0} = quiet; 1 = verbose, 2 = debug; 3 = verbose debug
%
\end{footnote}
\\
\hline
y
&
false
&
B
&
sync data after web request? %
\begin{footnote}[7]\sphinxAtStartFootnote
If \sphinxstylestrong{-w=true}, a file name is automatically generated from the request parameters, in addition to parsing data to a SeisData structure. Files are created from the raw download even if data processing fails, in contrast to get\_data(… wsac=true).
%
\end{footnote}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Table Footnotes}


\subsection{SeedLink Keywords}
\label{\detokenize{src/Appendices/keywords:seedlink-keywords}}
Change these with SeisIO.KW.SL.{[}key{]} = value, e.g., SeisIO.KW.SL.refresh = 30.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{48}|\X{8}{48}|\X{8}{48}|\X{24}{48}|}
\hline
\sphinxstyletheadfamily 
kw
&\sphinxstyletheadfamily 
def
&\sphinxstyletheadfamily 
type
&\sphinxstyletheadfamily 
meaning
\\
\hline
gap
&
3600
&
R
&
a stream with no data in \textgreater{}gap seconds is considered offline
\\
\hline
kai
&
600
&
R
&
keepalive interval (s)
\\
\hline
mode
&
“DATA”
&
I
&
“TIME”, “DATA”, or “FETCH”
\\
\hline
port
&
18000
&
I
&
port number
\\
\hline
refresh
&
20
&
R
&
base refresh interval (s) %
\begin{footnote}[8]\sphinxAtStartFootnote
This value is modified slightly by each SeedLink session to minimize the risk of congestion
%
\end{footnote}
\\
\hline
x\_on\_err
&
true
&
Bool
&
exit on error?
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Table Footnotes}


\section{Examples}
\label{\detokenize{src/Appendices/examples:examples}}\label{\detokenize{src/Appendices/examples:webex}}\label{\detokenize{src/Appendices/examples::doc}}

\subsection{FDSN data query}
\label{\detokenize{src/Appendices/examples:fdsn-data-query}}
1. Download 10 minutes of data from four stations at Mt. St. Helens (WA, USA), delete the low-gain channels, and save as SAC files in the current directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDSN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.VALT, UW.SEP, UW.SHW, UW.HSR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{src}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{600}\PYG{p}{)}
\PYG{n}{S} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SHW.ELZ..UW}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HSR.ELZ..UW}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{writesac}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}
\end{sphinxVerbatim}

2. Get 5 stations, 2 networks, all channels, last 600 seconds of data at IRIS

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CHA} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.PALM, UW.HOOD, UW.TIMB, CC.HIYU, UW.TDH}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{TS} \PYG{o}{=} \PYG{n}{u2d}\PYG{p}{(}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{TT} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{600}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDSN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CHA}\PYG{p}{,} \PYG{n}{src}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{TS}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{TT}\PYG{p}{)}
\end{sphinxVerbatim}

3. A request to FDSN Potsdam, time-synchronized, with some verbosity

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ts} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2011\PYGZhy{}03\PYGZhy{}11T06:00:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{te} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2011\PYGZhy{}03\PYGZhy{}11T06:05:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{R} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDSN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GE.BKB..BH?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{src}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GFZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{ts}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{te}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{true}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{FDSN station query}
\label{\detokenize{src/Appendices/examples:fdsn-station-query}}
A sample FDSN station query

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{FDSNsta}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.VALT..,PB.B001..BS?,PB.B001..E??}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{FDSN event header/data query}
\label{\detokenize{src/Appendices/examples:fdsn-event-header-data-query}}
Get seismic and strainmeter records for the P-wave of the Tohoku-Oki great earthquake on two borehole stations and write to native SeisData format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{FDSNevt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{201103110547}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PB.B004..EH?,PB.B004..BS?,PB.B001..BS?,PB.B001..EH?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{wseis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{201103110547\PYGZus{}evt.seis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{S}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{IRISWS data query}
\label{\detokenize{src/Appendices/examples:irisws-data-query}}
Note that the “src” keyword is not used in IRIS queries.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Get trace data from IRISws from \sphinxcode{\sphinxupquote{TS}} to \sphinxcode{\sphinxupquote{TT}} at channels \sphinxcode{\sphinxupquote{CHA}}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
S = SeisData()
CHA = \PYGZdq{}UW.TDH..EHZ, UW.VLL..EHZ, CC.VALT..BHZ\PYGZdq{}
TS = u2d(time()\PYGZhy{}86400)
TT = 600
get\PYGZus{}data!(S, \PYGZdq{}IRIS\PYGZdq{}, CHA, s=TS, t=TT)
\end{sphinxVerbatim}

2. Get synchronized trace data from IRISws with a 55-second timeout on HTTP requests, written directly to disk.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CHA} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.TDH..EHZ, UW.VLL..EHZ, CC.VALT..BHZ}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{TS} \PYG{o}{=} \PYG{n}{u2d}\PYG{p}{(}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{TT} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{600}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CHA}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{TS}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{TT}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{true}\PYG{p}{,} \PYG{n}{to}\PYG{o}{=}\PYG{l+m+mi}{55}\PYG{p}{,} \PYG{n}{w}\PYG{o}{=}\PYG{n}{true}\PYG{p}{)}
\end{sphinxVerbatim}

3. Request 10 minutes of continuous vertical-component data from a small May 2016 earthquake swarm at Mt. Hood, OR, USA:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{STA} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.HOOD.\PYGZhy{}\PYGZhy{}.BHZ,CC.TIMB.\PYGZhy{}\PYGZhy{}.EHZ}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{TS} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2016\PYGZhy{}05\PYGZhy{}16T14:50:00}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYG{n}{TE} \PYG{o}{=} \PYG{l+m+mi}{600}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{STA}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{TS}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{TE}\PYG{p}{)}
\end{sphinxVerbatim}

4. Grab data from a predetermined time window in two different formats

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ts} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2016\PYGZhy{}03\PYGZhy{}23T23:10:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{te} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2016\PYGZhy{}03\PYGZhy{}23T23:17:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.JRO..BHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{ts}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{te}\PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sacbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{T} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.JRO..BHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{ts}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{te}\PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{miniseed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{SeedLink sessions}
\label{\detokenize{src/Appendices/examples:seedlink-sessions}}
1. An attended SeedLink session in DATA mode. Initiate a SeedLink session in DATA mode using config file SL.conf and write all packets received directly to file (in addition to parsing to S itself). Set nominal refresh interval for checking for new data to 10 s. A mini-seed file will be generated automatically.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
S = SeisData()
SeedLink!(S, \PYGZdq{}SL.conf\PYGZdq{}, mode=\PYGZdq{}DATA\PYGZdq{}, r=10, w=true)
\end{sphinxVerbatim}

2. An unattended SeedLink download in TIME mode. Get the next two minutes of data from stations GPW, MBW, SHUK in the UW network. Put the Julia REPL to sleep while the request fills. If the connection is still open, close it (SeedLink’s time bounds arent precise in TIME mode, so this may or may not be necessary). Pause briefly so that the last data packets are written. Synchronize results and write data in native SeisIO file format.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sta = \PYGZdq{}UW.GPW,UW.MBW,UW.SHUK\PYGZdq{}
s0 = now()
S = SeedLink(sta, mode=\PYGZdq{}TIME\PYGZdq{}, s=s0, t=120, r=10)
sleep(180)
isopen(S.c[1]) \PYGZam{}\PYGZam{} close(S.c[1])
sleep(20)
sync!(S)
fname = string(\PYGZdq{}GPW\PYGZus{}MBW\PYGZus{}SHUK\PYGZdq{}, s0, \PYGZdq{}.seis\PYGZdq{})
wseis(fname, S)
\end{sphinxVerbatim}

3. A SeedLink session in TIME mode

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sta} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.GPW, UW.MBW, UW.SHUK}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S1} \PYG{o}{=} \PYG{n}{SeedLink}\PYG{p}{(}\PYG{n}{sta}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TIME}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{l+m+mi}{120}\PYG{p}{)}
\end{sphinxVerbatim}

4. A SeedLink session in DATA mode with multiple servers, including a config file. Data are parsed roughly every 10 seconds. A total of 5 minutes of data are requested.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sta = [\PYGZdq{}CC.SEP\PYGZdq{}, \PYGZdq{}UW.HDW\PYGZdq{}]
\PYGZsh{} To ensure precise timing, we\PYGZsq{}ll pass d0 and d1 as strings
st = 0.0
en = 300.0
dt = en\PYGZhy{}st
(d0,d1) = parsetimewin(st,en)

S = SeisData()
SeedLink!(S, sta, mode=\PYGZdq{}TIME\PYGZdq{}, r=10.0, s=d0, t=d1)
println(stdout, \PYGZdq{}...first link initialized...\PYGZdq{})

\PYGZsh{} Seedlink with a config file
config\PYGZus{}file = \PYGZdq{}seedlink.conf\PYGZdq{}
SeedLink!(S, config\PYGZus{}file, r=10.0, mode=\PYGZdq{}TIME\PYGZdq{}, s=d0, t=d1)
println(stdout, \PYGZdq{}...second link initialized...\PYGZdq{})

\PYGZsh{} Seedlink with a config string
SeedLink!(S, \PYGZdq{}CC.VALT..???, UW.ELK..EHZ\PYGZdq{}, mode=\PYGZdq{}TIME\PYGZdq{}, r=10.0, s=d0, t=d1)
println(stdout, \PYGZdq{}...third link initialized...\PYGZdq{})
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}